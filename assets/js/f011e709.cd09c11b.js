(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{140:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return o})),n.d(t,"default",(function(){return s}));var a=n(3),r=n(7),l=(n(0),n(147)),i={title:"Table API"},c={unversionedId:"flink-connectors/table-api",id:"flink-connectors/table-api",isDocsHomePage:!1,title:"Table API",description:"\x3c!--",source:"@site/docs/flink-connectors/table-api.md",slug:"/flink-connectors/table-api",permalink:"/docs/flink-connectors/table-api",editUrl:"https://github.com/claudiofahey/flink-connectors/edit/docusaurus/documentation/src/docs/table-api.md",version:"current",sidebar:"mainSidebar",previous:{title:"Batch",permalink:"/docs/flink-connectors/batch"},next:{title:"Metrics",permalink:"/docs/flink-connectors/metrics"}},o=[{value:"Table of Contents",id:"table-of-contents",children:[]},{value:"Introduction",id:"introduction",children:[]},{value:"How to create a table",id:"how-to-create-a-table",children:[]},{value:"Connector options",id:"connector-options",children:[]},{value:"Features",id:"features",children:[{value:"Batch and Streaming read",id:"batch-and-streaming-read",children:[]},{value:"Specify start and end streamcut",id:"specify-start-and-end-streamcut",children:[]},{value:"Changelog Source",id:"changelog-source",children:[]},{value:"Routing key by column",id:"routing-key-by-column",children:[]},{value:"Consistency guarantees",id:"consistency-guarantees",children:[]}]},{value:"Useful Flink links",id:"useful-flink-links",children:[]}],b={toc:o};function s(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"The Flink connector library for Pravega provides a table source and table sink for use with the Flink Table API.\nThe Table API provides a unified table source API for both the Flink streaming and batch environment, and also sink for the Flink streaming environment."),Object(l.b)("p",null,"It is possible to treat the Pravega streams as tables with the help of Flink."),Object(l.b)("p",null,"See the below sections for details."),Object(l.b)("h2",{id:"table-of-contents"},"Table of Contents"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#introduction"},"Introduction")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#how-to-create-a-table"},"How to create a table")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#connector-options"},"Connector options")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#features"},"Features"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#batch-and-streaming-read"},"Batch and Streaming read")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#specify-start-and-end-streamcut"},"Specify start and end streamcut")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#changelog-source"},"Changelog Source")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#routing-key-by-column"},"Routing key by column")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#consistency-guarantees"},"Consistency guarantees")))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#useful-flink-links"},"Useful Flink links"))),Object(l.b)("h2",{id:"introduction"},"Introduction"),Object(l.b)("p",null,"Before Flink 1.10 connector, the connector has implemented Flink legacy ",Object(l.b)("inlineCode",{parentName:"p"},"TableFactory")," interface to support table mapping,\nand provided ",Object(l.b)("inlineCode",{parentName:"p"},"FlinkPravegaTableSource")," and ",Object(l.b)("inlineCode",{parentName:"p"},"FlinkPravegaTableSink")," to read and write Pravega as Flink tables via a Pravega descriptor."),Object(l.b)("p",null,"Since Flink 1.11 connector, as Flink introduces a new Table API with ",Object(l.b)("a",{parentName:"p",href:"https://cwiki.apache.org/confluence/display/FLINK/FLIP-95%3A+New+TableSource+and+TableSink+interfaces"},"FLIP-95"),",\nwe integrate Flink ",Object(l.b)("inlineCode",{parentName:"p"},"Factory")," interface and provided ",Object(l.b)("inlineCode",{parentName:"p"},"FlinkPravegaDynamicTableSource")," and ",Object(l.b)("inlineCode",{parentName:"p"},"FlinkPravegaDynamicTableSink")," to simplify the application coding. "),Object(l.b)("p",null,"Note that the legacy table API is deprecated and will be removed in the future releases, we strongly suggest users to switch to the new table API.\nWe will focus on the new table API introduction in the document below, please refer to the documentation of older versions if you want to check the legacy table API."),Object(l.b)("p",null,"Pravega table source supports both the Flink ",Object(l.b)("strong",{parentName:"p"},"streaming")," and ",Object(l.b)("strong",{parentName:"p"},"batch")," environments.\nPravega table sink is an append-only table sink, it does NOT support upsert/retract output."),Object(l.b)("h2",{id:"how-to-create-a-table"},"How to create a table"),Object(l.b)("p",null,"Pravega Stream can be used as a table source/sink within a Flink table program.\nThe example below shows how to create a table connecting a Pravega stream as both source and sink:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-sql"},"create table pravega (\n    user_id STRING,\n    item_id BIGINT,\n    category_id BIGINT,\n    behavior STRING,\n    log_ts TIMESTAMP(3),\n    ts as log_ts + INTERVAL '1' SECOND,\n    watermark for ts as ts\n    )\nwith (\n    'connector' = 'pravega'\n    'controller-uri' = 'tcp://localhost:9090',\n    'scope' = 'scope',\n    'scan.execution.type' = 'streaming',\n    'scan.reader-group.name' = 'group1',\n    'scan.streams' = 'stream',\n    'sink.stream' = 'stream',\n    'sink.routing-key.field.name' = 'user_id',\n    'format' = 'json'\n    )\n")),Object(l.b)("h2",{id:"connector-options"},"Connector options"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null},"Option"),Object(l.b)("th",{parentName:"tr",align:null},"Required"),Object(l.b)("th",{parentName:"tr",align:null},"Default"),Object(l.b)("th",{parentName:"tr",align:null},"Type"),Object(l.b)("th",{parentName:"tr",align:null},"Description"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"connector"),Object(l.b)("td",{parentName:"tr",align:null},"required"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"Specify what connector to use, here should be 'pravega'")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"controller-uri"),Object(l.b)("td",{parentName:"tr",align:null},"required"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"Pravega controller URI")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"security.auth-type"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"Static authentication/authorization type for security")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"security.auth-token"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"Static authentication/authorization token for security")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"security.validate-hostname"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"Boolean"),Object(l.b)("td",{parentName:"tr",align:null},"If host name validation should be enabled when TLS is enabled")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"security.trust-store"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"Trust Store for Pravega client")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"scan.execution.type"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"streaming"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"Execution type for scan source. Valid values are 'streaming', 'batch'.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"scan.reader-group.name"),Object(l.b)("td",{parentName:"tr",align:null},"required for streaming source"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"Pravega reader group name")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"scan.streams"),Object(l.b)("td",{parentName:"tr",align:null},"required for source"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"List","<","String",">"),Object(l.b)("td",{parentName:"tr",align:null},"Semicolon-separated list of stream names from which the table is read.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"scan.start-streamcuts"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"List","<","String",">"),Object(l.b)("td",{parentName:"tr",align:null},"Semicolon-separated list of base64 encoded strings for start streamcuts, begin of the stream if not specified")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"scan.end-streamcuts"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"List","<","String",">"),Object(l.b)("td",{parentName:"tr",align:null},"Semicolon-separated list of base64 encoded strings for end streamcuts, unbounded end if not specified")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"scan.reader-group.max-outstanding-checkpoint-request"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"3"),Object(l.b)("td",{parentName:"tr",align:null},"Integer"),Object(l.b)("td",{parentName:"tr",align:null},"Maximum outstanding checkpoint requests to Pravega")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"scan.reader-group.refresh.interval"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"3 s"),Object(l.b)("td",{parentName:"tr",align:null},"Duration"),Object(l.b)("td",{parentName:"tr",align:null},"Refresh interval for reader group")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"scan.event-read.timeout.interval"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"1 s"),Object(l.b)("td",{parentName:"tr",align:null},"Duration"),Object(l.b)("td",{parentName:"tr",align:null},"Timeout for the call to read events from Pravega")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"scan.reader-group.checkpoint-initiate-timeout.interval"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"5 s"),Object(l.b)("td",{parentName:"tr",align:null},"Duration"),Object(l.b)("td",{parentName:"tr",align:null},"Timeout for call that initiates the Pravega checkpoint")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"sink.stream"),Object(l.b)("td",{parentName:"tr",align:null},"required for sink"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"Stream name to which the table is written")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"sink.semantic"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"at-least-once"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"Semantic when commit. Valid values are 'at-least-once', 'exactly-once', 'best-effort'")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"sink.txn-lease-renewal.interval"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"30 s"),Object(l.b)("td",{parentName:"tr",align:null},"Duration"),Object(l.b)("td",{parentName:"tr",align:null},"Transaction lease renewal period, valid for exactly-once semantic.")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"sink.enable.watermark-propagation"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"false"),Object(l.b)("td",{parentName:"tr",align:null},"Boolean"),Object(l.b)("td",{parentName:"tr",align:null},"If watermark propagation should be enabled from Flink table to Pravega stream")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"sink.routing-key.field.name"),Object(l.b)("td",{parentName:"tr",align:null},"optional"),Object(l.b)("td",{parentName:"tr",align:null},"(none)"),Object(l.b)("td",{parentName:"tr",align:null},"String"),Object(l.b)("td",{parentName:"tr",align:null},"Field name to use as a Pravega event routing key, field type must be STRING, random routing if not specified.")))),Object(l.b)("h2",{id:"features"},"Features"),Object(l.b)("h3",{id:"batch-and-streaming-read"},"Batch and Streaming read"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"scan.execution.type")," can be specified as user's choice to perform batch read or streaming read.\nIn the streaming environment, the table source uses a ",Object(l.b)("a",{parentName:"p",href:"/docs/flink-connectors/streaming#flinkpravegareader"},Object(l.b)("inlineCode",{parentName:"a"},"FlinkPravegaReader"))," connector.\nIn the batch environment, the table source uses a ",Object(l.b)("a",{parentName:"p",href:"/docs/flink-connectors/batch#flinkpravegainputformat"},Object(l.b)("inlineCode",{parentName:"a"},"FlinkPravegaInputFormat"))," connector.\nPlease see the documentation of ",Object(l.b)("a",{parentName:"p",href:"/docs/flink-connectors/streaming"},"Streaming Connector")," and ",Object(l.b)("a",{parentName:"p",href:"/docs/flink-connectors/batch"},"Batch Connector")," to have a better understanding on the below mentioned parameter list."),Object(l.b)("h3",{id:"specify-start-and-end-streamcut"},"Specify start and end streamcut"),Object(l.b)("p",null,"A ",Object(l.b)("inlineCode",{parentName:"p"},"StreamCut")," represents a consistent position in the stream, and can be fetched from other applications uses Pravega client through checkpoints or custom defined index.\n",Object(l.b)("inlineCode",{parentName:"p"},"scan.start-streamcuts")," and ",Object(l.b)("inlineCode",{parentName:"p"},"scan.end-streamcuts"),' can be specified to perform bounded read and "start-at-some-point" read for Pravega streams.\nPravega source supports read from multiple streams, and if read from multiple streams, please make sure the order of the streamcuts keeps the same as the order of the streams.'),Object(l.b)("h3",{id:"changelog-source"},"Changelog Source"),Object(l.b)("p",null,"If messages in Pravega stream is change event captured from other databases using CDC tools, then you can use a CDC format to interpret messages as INSERT/UPDATE/DELETE messages into Flink SQL system.\nFlink provides two CDC formats ",Object(l.b)("a",{parentName:"p",href:"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/connectors/formats/debezium.html"},Object(l.b)("inlineCode",{parentName:"a"},"debezium-json"))," and ",Object(l.b)("a",{parentName:"p",href:"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/connectors/formats/canal.html"},Object(l.b)("inlineCode",{parentName:"a"},"canal-json"))," to interpret change events captured by Debezium and Canal.\nThe changelog source is a very useful feature in many cases, such as synchronizing incremental data from databases to other systems, auditing logs, materialized views on databases, temporal join changing history of a database table and so on.\nSee more about how to use the CDC formats in ",Object(l.b)("a",{parentName:"p",href:"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/connectors/formats/debezium.html"},Object(l.b)("inlineCode",{parentName:"a"},"debezium-json"))," and ",Object(l.b)("a",{parentName:"p",href:"https://ci.apache.org/projects/flink/flink-docs-release-1.11/dev/table/connectors/formats/canal.html"},Object(l.b)("inlineCode",{parentName:"a"},"canal-json"))),Object(l.b)("h3",{id:"routing-key-by-column"},"Routing key by column"),Object(l.b)("p",null,"Pravega writers can use domain specific meaningful Routing Keys (like customer ID, Timestamp, Machine ID, etc.) to group similar together and make such parallelism with segment scaling.\nPravega makes ordering guarantees in terms of routing keys.\nPravega sink supports event routing according to a certain event field by specifying ",Object(l.b)("inlineCode",{parentName:"p"},"sink.routing-key.field.name"),". This field type must be ",Object(l.b)("inlineCode",{parentName:"p"},"STRING"),", and it will be random routing if not specified."),Object(l.b)("h3",{id:"consistency-guarantees"},"Consistency guarantees"),Object(l.b)("p",null,"By default, a Pravega sink ingests data with at-least-once guarantees if the query is executed with checkpointing enabled.\n",Object(l.b)("inlineCode",{parentName:"p"},"sink.semantic: exactly-once")," can be specified to turn on the transactional writes with exactly-once guarantees."),Object(l.b)("h2",{id:"useful-flink-links"},"Useful Flink links"),Object(l.b)("p",null,"Users can try with Pravega table APIs quickly though Flink SQL client. Here is some tutorial to setup the environment.\n",Object(l.b)("a",{parentName:"p",href:"https://ci.apache.org/projects/flink/flink-docs-stable/dev/table/sqlClient.html"},"https://ci.apache.org/projects/flink/flink-docs-stable/dev/table/sqlClient.html")),Object(l.b)("p",null,"The usage and definition of time attribute and WATERMARK schema can be referred in:\n",Object(l.b)("a",{parentName:"p",href:"https://ci.apache.org/projects/flink/flink-docs-stable/dev/table/streaming/time_attributes.html"},"https://ci.apache.org/projects/flink/flink-docs-stable/dev/table/streaming/time_attributes.html")))}s.isMDXComponent=!0},147:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var b=r.a.createContext({}),s=function(e){var t=r.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=s(e.components);return r.a.createElement(b.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,i=e.parentName,b=o(e,["components","mdxType","originalType","parentName"]),p=s(n),d=a,m=p["".concat(i,".").concat(d)]||p[d]||u[d]||l;return n?r.a.createElement(m,c(c({ref:t},b),{},{components:n})):r.a.createElement(m,c({ref:t},b))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,i=new Array(l);i[0]=d;var c={};for(var o in t)hasOwnProperty.call(t,o)&&(c[o]=t[o]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var b=2;b<l;b++)i[b]=n[b];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);