(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{138:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return l})),a.d(t,"toc",(function(){return s})),a.d(t,"default",(function(){return m}));var n=a(3),r=a(7),i=(a(0),a(168)),o={title:"Watermarking"},l={unversionedId:"pravega/watermarking",id:"pravega/watermarking",isDocsHomePage:!1,title:"Watermarking",description:"\x3c!--",source:"@site/docs/pravega/watermarking.md",slug:"/pravega/watermarking",permalink:"/docs/docs/pravega/watermarking",editUrl:"https://github.com/claudiofahey/pravega/edit/docusaurus/documentation/src/docs/watermarking.md",version:"current",sidebar:"mainSidebar",previous:{title:"Reader Groups Design",permalink:"/docs/docs/pravega/reader-group-design"},next:{title:"Methods for Writing and Reading Pravega Streams",permalink:"/docs/docs/pravega/pravega-write-read-methods"}},s=[{value:"Concepts related to watermarking",id:"concepts-related-to-watermarking",children:[{value:"The watermark",id:"the-watermark",children:[]},{value:"Time window",id:"time-window",children:[]},{value:"Time",id:"time",children:[]}]},{value:"How Pravega Writers report time",id:"how-pravega-writers-report-time",children:[{value:"Explicitly note time",id:"explicitly-note-time",children:[]},{value:"Note time on transaction commit",id:"note-time-on-transaction-commit",children:[]},{value:"Automatically attach wall clock time",id:"automatically-attach-wall-clock-time",children:[]}]},{value:"How Pravega Readers request watermark windows",id:"how-pravega-readers-request-watermark-windows",children:[]},{value:"Preventing a stalled watermark",id:"preventing-a-stalled-watermark",children:[]},{value:"Integration with applications",id:"integration-with-applications",children:[]}],c={toc:s};function m(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Stream-processing applications may require a time-bounded set of metrics to make a calculation, make a decision, or\ncommit a transaction. Pravega watermarking provides a way for applications to define time and know with some certainty\nthat it has a complete set of data up to a watermark. All events earlier than a watermark can be processed, acted upon,\nor committed."),Object(i.b)("p",null,"In Pravega stream processing, data ingress is typically handled by multiple Pravega Writers, and data processing is\ntypically handled by multiple Pravega Readers. In a parallel processing scenario, events can ingress out of order (even\nthough final order is guaranteed). Out of order ingress and the possibility of delayed Writers make it difficult for\na Reader application to know when a complete set of events exists for any given time window. How long should a Reader\nwait before deciding that it has all of the events for a defined time window?  Watermarking satisfies that question."),Object(i.b)("p",null,"In general, watermarking works like this:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The concept of time is defined by the application."),Object(i.b)("li",{parentName:"ul"},"Pravega Writers report their time and positions in the stream (or use a feature that automatically timestamps events).  "),Object(i.b)("li",{parentName:"ul"},"The Pravega controller periodically consolidates the reports into watermarks. The watermark defines both time and a\nstream position."),Object(i.b)("li",{parentName:"ul"},"Pravega Readers request time windows and use them to navigate the stream. The lower bound of a returned time window is\nthe current watermark."),Object(i.b)("li",{parentName:"ul"},"The application can process data with some certainty that the data is complete up to the watermarked time and position.       ")),Object(i.b)("h2",{id:"concepts-related-to-watermarking"},"Concepts related to watermarking"),Object(i.b)("h3",{id:"the-watermark"},"The watermark"),Object(i.b)("p",null,"The controller produces data structures called watermarks. A watermark has three values:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"lowerTimeBound")," -  a lower bound time corresponding to the streamcut.  A watermark makes a weak claim that all events in\nthe stream after the ",Object(i.b)("inlineCode",{parentName:"li"},"watermark.streamcut")," have time greater than ",Object(i.b)("inlineCode",{parentName:"li"},"watermark.lowerbound"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"upperTimeBound")," -  an upper bound time corresponding to the streamcut. A watermark makes a weak suggestion that all\nevents it saw up to ",Object(i.b)("inlineCode",{parentName:"li"},"watermark.streamcut")," have an upper bound time of watermark.upperBound."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"streamcut(position)")," - an upper bound on positions from all writers with respect to the lower bound time.")),Object(i.b)("p",null,"A streamcut is a logical partition of a stream. It corresponds to a ",Object(i.b)("inlineCode",{parentName:"p"},"segment to offset")," mapping in the stream. Since a\nstream is partitioned into multiple segments, a stream cut divides the stream such that you can perform bounded\nprocessing before or after that stream cut. Since stream cut spans multiple segments, offsets in each segment correspond\nto individual events written within those segments."),Object(i.b)("h3",{id:"time-window"},"Time window"),Object(i.b)("p",null,"A Reader requests a time window. A Time window contains two watermarks."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"lowerTimeBound")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"upperTimeBound"))),Object(i.b)("p",null,"In the following example, the two watermarks are W1 and W2."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"TimeWindow T1 = {W1.lowerbound, W2.upperbound}\n")),Object(i.b)("p",null,"Pravega makes a weak claim that all events between ",Object(i.b)("inlineCode",{parentName:"p"},"W1.streamCut")," and ",Object(i.b)("inlineCode",{parentName:"p"},"W2.streamCut")," have times that fall in the\ntimewindow ",Object(i.b)("inlineCode",{parentName:"p"},"T1"),"."),Object(i.b)("h3",{id:"time"},"Time"),Object(i.b)("p",null,"The concept of time is defined by the application. The Pravega APIs provide the means for Writers to note the time and\nfor Readers to request the watermarked window of time, but the definition of time itself is controlled by the\napplication."),Object(i.b)("p",null,"The time may indicate the time the data was written to the stream (ingestion time). Time may alternatively be equated\nto event time (the time the event occurred).  Time can denote wall clock time, some other traditional time, or an\narbitrary value, like a file number that advances as the application ingests file data."),Object(i.b)("p",null,"Time has two requirements:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Time is a variable of type ",Object(i.b)("inlineCode",{parentName:"li"},"long"),".  "),Object(i.b)("li",{parentName:"ul"},"Time must increase monotonically. That is, if time is 6, then a time of 5 is earlier, and a time of 7\nis later.")),Object(i.b)("h2",{id:"how-pravega-writers-report-time"},"How Pravega Writers report time"),Object(i.b)("p",null,"A Writer reports time corresponding to a position. A position identifies the location within a stream where the Writer\nlast wrote something."),Object(i.b)("p",null,"There are three ways for Pravega Writers to report time."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Explicitly note the time  "),Object(i.b)("li",{parentName:"ul"},"Note time on transaction commit"),Object(i.b)("li",{parentName:"ul"},"Automatically note wall clock time")),Object(i.b)("h3",{id:"explicitly-note-time"},"Explicitly note time"),Object(i.b)("p",null,"The following API method notes time. The position is captured with time."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"writer.noteTime(long timestamp);  \n")),Object(i.b)("p",null,"A Writer can note time after every event write, after writing ",Object(i.b)("inlineCode",{parentName:"p"},"n")," number of events, or use it periodically to indicate\nthe time and position."),Object(i.b)("p",null,"Here is example usage:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"EventStreamWriter<EventType> writer = clientFactory.createEventWriter(stream, serializer,EventWriterConfig.builder().build());\n\n      //... write events ...\n\nwriter.noteTime(currentTime);\n")),Object(i.b)("h3",{id:"note-time-on-transaction-commit"},"Note time on transaction commit"),Object(i.b)("p",null,"For transactional writes, the commit call can supply the timestamp. The following Writer method passes the time to the\nController as part of the commit."),Object(i.b)("p",null,"For example:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"void commit(long timestamp) throws TxnFailedException;\n\nTransaction<EventType> txn = writer.beginTxn();\n\n        //... write events to transaction.\n\ntxn.commit(txnTimestamp);\n")),Object(i.b)("p",null,"During processing, all transaction segments are merged into parent segments. This can happen for a batch of\ntransactions. As they are merged, the merge offsets are recorded by the controller and composed into a position object\nfor where the transaction write completed. Within a committed batch of transactions, writer-specific times are calculated\nand reported. The watermarking workflow uses these reported times and positions in its next periodic cycle to compute\nthe watermark bounds."),Object(i.b)("h3",{id:"automatically-attach-wall-clock-time"},"Automatically attach wall clock time"),Object(i.b)("p",null,"You can set the ",Object(i.b)("inlineCode",{parentName:"p"},"automaticallyNoteTime")," option to true when a Writer is created. This option configures the Writer to\nautomatically attach a system time notation to every event. The option essentially attaches the ingest time to each\nevent. With this option turned on, no other calls to note the time are required."),Object(i.b)("p",null,"Here is an example that configures automatic timestamps on events:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"EventStreamWriter<EventType> writer = clientFactory.createEventWriter(stream, serializer,\n        EventWriterConfig.builder().automaticallyNoteTime(true).build());\n")),Object(i.b)("h2",{id:"how-pravega-readers-request-watermark-windows"},"How Pravega Readers request watermark windows"),Object(i.b)("p",null,"Multiple Pravega Readers working in parallel each have different current locations in the stream. The Controller\ncoordinates the Reader positions and can return a window that indicates where in the stream all of the readers are."),Object(i.b)("p",null,"The following Reader API method requests the current watermark window."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"TimeWindow window = reader.getTimeWindow();")),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"TimeWindow")," is returned as:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"  public class TimeWindow {\n      private final long lowerTimeBound;\n      private final long upperTimeBound;\n  }\n")),Object(i.b)("p",null,"where:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"lowerTimeBound")," of the  window is the watermark. The Controller asserts that all readers are done reading all events\nearlier than the watermark."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"upperTimeBound")," is an arbitrary assignment that can help applications keep track of a moving window of time.")),Object(i.b)("p",null,"The lower bound is most important as it corresponds to the low watermark. It takes into account the position of all\nof the readers and represents the time before which all events have been read, under the assumption that ingestion\nrespected this order. Events of course can arrive out of order, in which case the low watermark becomes only a strong\nindication that all the events with a lower timestamp have been read. When using this time window for window\naggregation, there is a point in which any given window needs to be declared closed, so that processing can occur. For\nexample, say that we want to count occurrences every hour. When the lower time bound advances to the hour, the\napplication may choose to immediately close the window and perform the count or wait longer. The choice is up to the\napplication."),Object(i.b)("p",null,"If a reader asks for a time window from a stream whose writers are not generating time stamps, then `null is returned."),Object(i.b)("p",null,"The TimeWindow reflects the current position in the stream. It can be called following every ",Object(i.b)("inlineCode",{parentName:"p"},"readNextEvent()")," call if\ndesired, or just periodically to provide support for grouping events into windows."),Object(i.b)("h2",{id:"preventing-a-stalled-watermark"},"Preventing a stalled watermark"),Object(i.b)("p",null,"If a Pravega Writer goes down or is delayed and stops writing events, the Readers wait for possible delayed events from\nthat Writer. As a result, watermarks stop advancing.  While it is desirable for Readers to wait for delayed events, at\nsome point it makes sense to stop waiting. For example, perhaps the Writer is offline and is not coming back. The\ncontroller must be allowed to emit a best attempt watermark so processing can continue."),Object(i.b)("p",null,"To prevent Readers from waiting indefinitely for a Writer, you can configure the ",Object(i.b)("inlineCode",{parentName:"p"},"timestampAggregationTimeout")," parameter\non a stream. This parameter configures the amount of time after which a Writer that has not been heard from will be\nexcluded from the time window calculation.  Set this parameter on a stream when the stream is defined."),Object(i.b)("h2",{id:"integration-with-applications"},"Integration with applications"),Object(i.b)("p",null,"Typically, an application running a Pravega reader interested in processing with time obtains the low watermark from\nthe time window. The application then needs downstream operators to process the watermark. For example, Apache Flink\nis a stream processing engine that can propagate watermarks very well. We have a Pravega Flink connector that can get\na watermark from the Pravega Reader with the ",Object(i.b)("inlineCode",{parentName:"p"},"AssignerWithTimeWindows")," interface, which integrates the Pravega watermark\nfeature with the periodic watermark in Apache Flink. All Flink applications using Pravega can gain the benefits of event\ntime or ingest time watermarking using all the standard Apache Flink APIs."),Object(i.b)("p",null,"Watermarking support in Pravega is useful in general in event time windowing applications. The following example\napplication gets a Pravega watermark and uses Apache Flink to process it. It reads data from Pravega and calculates an\naverage in every event-time 10 minutes. The watermark is important to provide the signal in real time to start and close\nevery 10-minute window.  The example is ",Object(i.b)("a",{parentName:"p",href:"https://github.com/pravega/pravega-samples/blob/master/flink-connector-examples/src/main/java/io/pravega/example/flink/watermark/EventTimeAverage.java"},"here"),".\nA more in-depth description of the the example is ",Object(i.b)("a",{parentName:"p",href:"https://github.com/pravega/pravega-samples/blob/master/flink-connector-examples/doc/watermark/README.md"},"here"),"."))}m.isMDXComponent=!0},168:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return h}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),m=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=m(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=m(a),u=n,h=p["".concat(o,".").concat(u)]||p[u]||d[u]||i;return a?r.a.createElement(h,l(l({ref:t},c),{},{components:a})):r.a.createElement(h,l({ref:t},c))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,o[1]=l;for(var c=2;c<i;c++)o[c]=a[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);