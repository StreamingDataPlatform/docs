(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{123:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return s})),a.d(t,"toc",(function(){return l})),a.d(t,"default",(function(){return c}));var n=a(3),r=a(7),i=(a(0),a(147)),o={title:"Pravega Segment Store Service"},s={unversionedId:"pravega/segment-store-service",id:"pravega/segment-store-service",isDocsHomePage:!1,title:"Pravega Segment Store Service",description:"\x3c!--",source:"@site/docs/pravega/segment-store-service.md",slug:"/pravega/segment-store-service",permalink:"/docs/pravega/segment-store-service",editUrl:"https://github.com/claudiofahey/pravega/edit/docusaurus/documentation/src/docs/segment-store-service.md",version:"current",sidebar:"mainSidebar",previous:{title:"Frequently Asked Questions",permalink:"/docs/pravega/faq"},next:{title:"Segment Containers in a Pravega Cluster",permalink:"/docs/pravega/segment-containers"}},l=[{value:"System Diagram",id:"system-diagram",children:[]},{value:"Segment Containers",id:"segment-containers",children:[{value:"Segment Container Metadata",id:"segment-container-metadata",children:[]},{value:"Log Operations",id:"log-operations",children:[]},{value:"Durable Log",id:"durable-log",children:[]},{value:"Read Index",id:"read-index",children:[]},{value:"Cache",id:"cache",children:[]},{value:"Storage Writer",id:"storage-writer",children:[]}]},{value:"Segment Container Manager",id:"segment-container-manager",children:[]},{value:"Appends",id:"appends",children:[]},{value:"Reads",id:"reads",children:[]},{value:"Synchronization with Tier 2 (Storage Writer)",id:"synchronization-with-tier-2-storage-writer",children:[]},{value:"Container Startup (Normal/Recovery)",id:"container-startup-normalrecovery",children:[]}],b={toc:l};function c(e){var t=e.components,o=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},b,o,{components:t,mdxType:"MDXLayout"}),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#introduction"},"Introduction")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#terminology"},"Terminology")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#architecture"},"Architecture"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#system-diagram"},"System diagram")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#components"},"Components"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#segment-containers"},"Segment Containers"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#segment-container-metadata"},"Segment Container Metatdata"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#container-metadata"},"Container Metadata")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#segment-metadata"},"Segment Metadata")))))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#log-operations"},"Log Operations")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#durable-log"},"Durable Log"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#information-flow-in-the-durable-log"},"Information Flow")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#truncation"},"Truncation")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#operation-processor"},"Operation Processor")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#operation-metadata-updater"},"Operation Metadata Updater")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#durable-data-log"},"Durable Data Log")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#in-memory-operation-log"},"In-Memory Operation Log")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#read-index"},"Read Index")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#cache"},"Cache")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#storage-writer"},"Storage Writer")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#integration-with-controller"},"Integration with Controller"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#segment-container-manager"},"Segment Container Manager")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#storage-abstractions"},"Storage Abstraction")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#data-flow"},"Data Flow"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#appends"},"Appends")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#reads"},"Reads")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#synchronization-with-tier-2-storage-writer"},"Synchronization with Tier 2")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"#container-startup-normalrecovery"},"Container Startup"))))),Object(i.b)("h1",{id:"introduction"},"Introduction"),Object(i.b)("p",null,"The Pravega Segment Store Service is a subsystem that lies at the heart of the entire Pravega deployment. It is the main access point for managing ",Object(i.b)("strong",{parentName:"p"},"Stream Segments"),", providing the ability to ",Object(i.b)("em",{parentName:"p"},"create"),", ",Object(i.b)("em",{parentName:"p"},"delete")," and ",Object(i.b)("em",{parentName:"p"},"modify/access")," their contents. The Pravega client communicates with the Pravega Stream Controller to figure out which Stream Segments need to be used (for a Stream), and both the Stream Controller and the client deal with the Segment Store Service to operate on them."),Object(i.b)("p",null,"The basic idea behind the Segment Store Service is that it buffers the incoming data in a very fast and durable append-only medium (Tier 1), and syncs it to a high-throughput (but not necessarily low latency) system (Tier 2) in the background, while aggregating multiple (smaller) operations to a Stream Segment into a fewer (but larger) ones."),Object(i.b)("p",null,"The Pravega Segment Store Service can provide the following guarantees:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Stream Segments that are unlimited in length, with append-only semantics, yet supporting arbitrary-offset reads."),Object(i.b)("li",{parentName:"ul"},"No throughput degradation when performing small appends, regardless of the performance of the underlying Tier 2 Storage system."),Object(i.b)("li",{parentName:"ul"},"Multiple concurrent writers to the same Stream Segment."),Object(i.b)("li",{parentName:"ul"},"the order is guaranteed within the context of a single Writer, but appends from multiple concurrent Writers will be added in the order in which they were received (appends are atomic without interleaving their contents)."),Object(i.b)("li",{parentName:"ul"},"Writing to and reading from a Stream Segment concurrently with relatively low latency between writing and reading.")),Object(i.b)("h1",{id:"terminology"},"Terminology"),Object(i.b)("p",null,"The following terminologies are used throughout the document:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Stream Segment")," or ",Object(i.b)("strong",{parentName:"li"},"Segment"),": A contiguous sequence of bytes, similar to a file of unbounded size. This is a part of a Stream, limited both temporally and laterally (by key). The scope of Streams and mapping Stream Segments to such Streams is beyond the purpose of this document."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Tier 2 Storage")," or ",Object(i.b)("strong",{parentName:"li"},"Permanent Storage"),": The final resting place of the data."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Tier 1 Storage"),": Fast append storage, used for durable buffering of incoming appends before distributing to Tier 2 Storage."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Cache"),": A key-value local cache with no expectation of durability."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Pravega Segment Store Service")," or ",Object(i.b)("strong",{parentName:"li"},"Segment Store"),": The Service that this document describes."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Transaction"),": A sequence of appends that are related to a Segment, which, if persisted, would make up a contiguous range of bytes within it. This is used for ingesting very large records or for accumulating data that may or may not be persisted into the Segment (but its fate cannot be determined until later in the future).")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note:")," At the Pravega level, a Transaction applies to an entire Stream. In this document, a Transaction applies to a single Segment."),Object(i.b)("h1",{id:"architecture"},"Architecture"),Object(i.b)("p",null,"The ",Object(i.b)("strong",{parentName:"p"},"Segment Store")," is made up of the following components:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Pravega Node"),": A host running a Pravega Process."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Stream Segment Container")," (or ",Object(i.b)("strong",{parentName:"li"},"Segment Container"),"): A logical grouping of Stream Segments. The mapping of Segments to Containers is deterministic and does not require any persistent store; Segments are mapped to Containers via a hash function (based on the Segment's name)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Durable Data Log Adapter")," (or ",Object(i.b)("strong",{parentName:"li"},"Durable Data Log"),"): An abstraction layer for Tier 1 Storage."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Storage Adapter"),": An abstraction layer for Tier 2 Storage."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Cache"),": An abstraction layer for append data caching."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Streaming Client"),": An API that can be used to communicate with the Pravega Segment Store."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Segment Container Manager"),": A component that can be used to determine the lifecycle of Segment Containers on a Pravega Node. This is used to start or stop Segment Containers based on an external coordination service (such as the Pravega Controller).")),Object(i.b)("p",null,"The Segment Store handles writes by first writing them to a log (",Object(i.b)("em",{parentName:"p"},"Durable Data Log"),") on a fast storage (SSDs preferably) and immediately acking back to the client after they have been persisted there. Subsequently, those writes are then aggregated into larger chunks\xa0and written in the background to Tier 2 Storage. Data for appends that have been acknowledged (and are in Tier 1) but not yet in Tier 2 is stored in the Cache (in addition to Tier 1). Once such data has been written to Tier 2 Storage, it may or may not be kept in the Cache, depending on a number of factors, such as Cache utilization/pressure and access patterns."),Object(i.b)("p",null,"More details about each component described above can be found in the ",Object(i.b)("a",{parentName:"p",href:"#components"},"Components")," section."),Object(i.b)("h2",{id:"system-diagram"},"System Diagram"),Object(i.b)("p",null,Object(i.b)("img",{alt:"System Diagram",src:a(215).default})),Object(i.b)("p",null,"In the above diagram, the major components of the Segment Store are shown. But for simplicity, only one Segment Container is depicted. All Container components and major links between them (how they interact with each other) are shown. The ",Object(i.b)("em",{parentName:"p"},"Container Metadata")," component is not shown, because every other component communicates with it in one form or another and adding it would only clutter the diagram."),Object(i.b)("p",null,"More detailed diagrams can be found under the ",Object(i.b)("a",{parentName:"p",href:"#data-flow"},"Data Flow")," section."),Object(i.b)("h1",{id:"components"},"Components"),Object(i.b)("h2",{id:"segment-containers"},"Segment Containers"),Object(i.b)("p",null,"Segment Containers are a logical grouping of Segments and are responsible for all operations on those Segments within their span. A Segment Container is made of multiple sub-components:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Segment Container Metadata"),": A collection of Segment-specific metadata that describes the current state of each Segment (how much data in Tier 2, how much in Tier 1, whether it is sealed, etc.), as well as other miscellaneous info about each Container."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Durable Log"),": The Container writes every operation it receives to this log and acks back only when the log says it has been accepted and durably persisted."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Read Index"),":\xa0An in-memory index of where data can be read from. The Container delegates all read requests to it, and it is responsible for fetching the data from wherever it is currently located (Cache, Tier 1 Storage or Tier 2 Storage)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Cache"),":\xa0Used to store data for appends that exist in Tier 1 only (not yet in Tier 2), as well as blocks of data that support reads."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Storage Writer"),":\xa0Processes the durable log operations and applies them to Tier 2 Storage (in the order in which they were received). This component is also the one that coalesces multiple operations together, for better back-end throughput.")),Object(i.b)("h3",{id:"segment-container-metadata"},"Segment Container Metadata"),Object(i.b)("p",null,'The Segment Container Metadata is critical to the good functioning and synchronization of its components. This metadata is shared across all components and it comes at two levels: "Container-wide metadata" and "per-Segment metadata". Each serves a different purpose and is described below.'),Object(i.b)("h4",{id:"container-metadata"},"Container Metadata"),Object(i.b)("p",null,"Each ",Object(i.b)("strong",{parentName:"p"},"Segment Container")," needs to keep some general-purpose metadata that affects all operations inside the container:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Operation Sequence Number"),":\xa0The largest sequence number assigned by the ",Object(i.b)("em",{parentName:"li"},"Durable Log"),". Every time a new operation is received and successfully processed by the ",Object(i.b)("em",{parentName:"li"},"Durable Log"),", this number is incremented (its value will never decrease or otherwise rollback, even if an operation failed to be persisted).",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"The operation sequence number is guaranteed to be strict-monotonic increasing (no two operations have the same value, and an operation will always have a larger sequence number than all operations before it)."))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Epoch"),": A number that is incremented every time a successful recovery (Container Start) happens. This value is durably incremented and stored as part of recovery and can be used for a number of cases (a good use is Tier 2 fencing for HDFS, which doesn't provide a good, native mechanism for that)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Active Segment Metadata"),": Keeps information about each active Stream Segment. A Segment is active if it has had activity (read or write) recently and is currently loaded in memory. If a Stream Segment is idle for a while, or if there are many Stream Segments currently active, a Stream Segment becomes inactive by having its outstanding metadata flushed to Tier 2 Storage and evicted from memory."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Tier 1 Metadata"),": Various pieces of information that can be used to accurately truncate the Tier 1 Storage Log once all operations prior to that point have been durably stored to Tier 2."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Checkpoints"),": Container metadata is periodically Checkpointed by having its entire snapshot (including Active Segments) serialized to Tier 1. A Checkpoint serves as a Truncation Point for Tier 1, as it contains all the updates that have been made to the Container via all the processed operations before it, so we no longer need those operations in order to reconstruct the metadata. If we truncate Tier 1 on a Checkpoint, then we can use information from Tier 2 and this Checkpoint to reconstruct by using the previously available metadata, without relying on any operation prior to it in Tier 1.")),Object(i.b)("h4",{id:"segment-metadata"},"Segment Metadata"),Object(i.b)("p",null,"Each Segment Container needs to keep per-segment metadata, which it uses to keep track of the state of each segment as it processes operations for it. The metadata can be volatile (it can be fully rebuilt upon recovery) and contains the following properties for each segment that is currently in use:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"Name"),": The name of the Stream Segment."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"Id"),": Internally assigned unique Stream Segment ID. This is used to refer to Stream Segments, which is preferred to the Name. This ID is used for the entire lifetime of the Stream Segment, which means that even if the Stream Segment becomes inactive, a future reactivation will have it mapped to the same ID."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"StartOffset")," (also known as ",Object(i.b)("inlineCode",{parentName:"li"},"TruncationOffset"),"): The lowest offset of the data that is available for reading. A non-truncated Stream Segment will have Start Offset equal to ",Object(i.b)("em",{parentName:"li"},"0"),", while subsequent Truncate operations will increase (but never decreases) this number."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"StorageLength"),": The highest offset of the data that exists in Tier 2 Storage."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"Length"),": The highest offset of the committed data in\xa0Tier 1 Storage."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"LastModified"),": The timestamp of the last processed (and acknowledged) append."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"IsSealed"),": Whether the Stream Segment is closed for appends (this value may not have been applied to Tier 2 Storage yet)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"IsSealedInStorage"),": Whether the Stream Segment is closed for appends (and this has been persisted in Tier 2 Storage)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"IsMerged"),": Whether the Stream Segment has been merged into another one (but this has not yet been persisted in Tier 2 Storage). This only applies for Transactions. Once the merge is persisted into Tier 2, the Transaction Segment does not exist anymore (so ",Object(i.b)("inlineCode",{parentName:"li"},"IsDeleted")," will become true)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"IsDeleted"),": Whether the Stream Segment is deleted or has recently been merged into another Stream Segment. This only applies for recently deleted Stream Segments, and not for Stream Segments that never existed.")),Object(i.b)("p",null,"The following are\xa0always\xa0",Object(i.b)("strong",{parentName:"p"},"true")," for any Stream Segment:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"StorageLength"),"\xa0<=\xa0",Object(i.b)("inlineCode",{parentName:"li"},"Length")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"StartOffset"),"\xa0<=\xa0",Object(i.b)("inlineCode",{parentName:"li"},"Length"))),Object(i.b)("h3",{id:"log-operations"},"Log Operations"),Object(i.b)("p",null,"The ",Object(i.b)("strong",{parentName:"p"},"Log Operation")," is a basic unit that is enqueued in the ",Object(i.b)("em",{parentName:"p"},"Durable Log"),". It does not represent an action, per se, but is the base for several serializable operations (we can serialize multiple types of operations, not just Appends). Each operation is the result of an external action (which denote the alteration of a Stream Segment), or an internal trigger, such as metadata maintenance operations."),Object(i.b)("p",null,"Every Log operation has the following elements:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"SequenceNumber"),": The unique sequence number assigned to this entry (see more under ",Object(i.b)("a",{parentName:"li",href:"#segment-container-metadata"},"Container Metadata"),") section.")),Object(i.b)("p",null,"The following are the various types of Log operations:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Storage Operations"),": Represent operations that need to be applied to the underlying Tier 2 Storage:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"StreamSegmentAppendOperation"),": Represents an append to a particular Stream Segment."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"CachedStreamSegmentAppendOperation"),": Same as ",Object(i.b)("inlineCode",{parentName:"li"},"StreamSegmentAppendOperation"),", but this is for internal use (instead of having an actual data payload, it points to a location in the Cache from where the data can be retrieved)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"StreamSegmentSealOperation"),":\xa0When processed, it sets a flag in the in-memory metadata that no more appends can be received. When the\xa0Storage Writer\xa0processes it, it marks the Stream Segment as read-only in Tier 2 Storage."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"StreamSegmentTruncateOperation"),": Truncates a Stream Segment at a particular offset. This causes the Stream Segment's ",Object(i.b)("inlineCode",{parentName:"li"},"StartOffset")," to change."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"MergeTransactionOperation"),": Indicates that a Transaction is to be merged into its parent Stream Segment."))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Metadata Operations"),' are auxiliary operations that indicate a change to the Container metadata. They can be the result of an external operation (we received a request for a Stream Segment we never knew about before, so we must assign a "unique ID" to it) or to snapshot the entire metadata (which helps with recovery and cleaning up Tier 1 Storage). The purpose of the metadata operations is to reduce the amount of time needed for failover recovery (when needed).',Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"StreamSegmentMapOperation"),":\xa0Maps an ID to a Stream Segment Name."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"TransactionMapOperation"),":\xa0Maps an ID to a Transaction and to its Parent Segment."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"UpdateAttributesOperation"),": Updates any attributes on a Stream Segment."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"MetadataCheckpoint"),": Includes an entire snapshot of the metadata. This can be useful during recovery. This contains all metadata up to this point, which is a sufficient base for all operations after it.")))),Object(i.b)("h3",{id:"durable-log"},"Durable Log"),Object(i.b)("p",null,"The ",Object(i.b)("em",{parentName:"p"},"Durable Log")," is the central component that handles all Log operations. All operations (which are created by the Container) are added to the ",Object(i.b)("em",{parentName:"p"},"Durable Log"),", which processes them in the order in which they were received. It is made up of a few other components, all of which are working towards a single goal of processing all incoming operations as quickly as possible, without compromising data integrity."),Object(i.b)("h4",{id:"information-flow-in-the-durable-log"},"Information Flow in the Durable Log"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"All received operations are added to an ",Object(i.b)("em",{parentName:"p"},"Operation Queue")," (the caller receives a Future which will be completed when the operation is durably persisted).")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"The ",Object(i.b)("em",{parentName:"p"},"Operation Processor")," picks all operations currently available in the queue (if the queue is empty, it will wait until at least one operation is added).")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"The ",Object(i.b)("em",{parentName:"p"},"Operation Processor")," runs as a continuous loop (in a background thread), and executes the following steps."),Object(i.b)("ol",{parentName:"li"},Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},Object(i.b)("em",{parentName:"p"},"Dequeue")," all outstanding operations from the operation Queue (described above).")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},Object(i.b)("em",{parentName:"p"},"Pre-process")," the operations (validate that they are correct and would not cause undesired behavior, assign offsets (where needed), assign sequence numbers, etc.)")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},Object(i.b)("em",{parentName:"p"},"Write")," the operations to a ",Object(i.b)("em",{parentName:"p"},"Data Frame Builder"),", which serializes and packs the operations in ",Object(i.b)("em",{parentName:"p"},"Data Frames"),". Once a ",Object(i.b)("em",{parentName:"p"},"Data Frame")," is complete (full or no more operations to add), the ",Object(i.b)("em",{parentName:"p"},"Data Frame")," Builder sends the ",Object(i.b)("em",{parentName:"p"},"Data Frame")," to the ",Object(i.b)("em",{parentName:"p"},"Durable Data Log"),". Note that, an operation may span multiple ",Object(i.b)("em",{parentName:"p"},"DataFrames"),", but the goal is to make the best use of the ",Object(i.b)("em",{parentName:"p"},"Durable Data Log")," throughput capacity by making writes as large as possible considering the maximum size limit per write.")))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"When a ",Object(i.b)("em",{parentName:"p"},"Data Frame")," has been durably persisted in the ",Object(i.b)("em",{parentName:"p"},"Durable Data Log"),", the operation Processor post-processes all operations that were fully written so far. It adds them to in-memory structures, updates indices, etc., and completes the Futures associated with them.")),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"The ",Object(i.b)("em",{parentName:"p"},"Operation Processor")," works asynchronously, by not waiting for a particular ",Object(i.b)("em",{parentName:"p"},"Data Frame")," to be written before starting another one and sending it to the ",Object(i.b)("em",{parentName:"p"},"Durable Data Log"),". Likewise, multiple ",Object(i.b)("em",{parentName:"p"},"Data Frames")," may be in flight by maintaining a specific order. The operation Processor relies on certain ordering guarantees from the ",Object(i.b)("em",{parentName:"p"},"Durable Data Log"),", if a particular ",Object(i.b)("em",{parentName:"p"},"Data Frame")," was acked, it assures that all the prior ",Object(i.b)("em",{parentName:"p"},"Data Frames")," to it were also committed successfully, in the right order.  "))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note:")," The operation Processor does not do any write throttling. It leaves that to the ",Object(i.b)("em",{parentName:"p"},"Durable Data Log")," implementation, but it controls the size of the Data Frames that get sent to it."),Object(i.b)("h4",{id:"truncation"},"Truncation"),Object(i.b)("p",null,"Based on supplied configuration, the ",Object(i.b)("em",{parentName:"p"},"Durable Log")," auto-adds a special kind of operation, named ",Object(i.b)("inlineCode",{parentName:"p"},"MetadataCheckpointOperation"),". This operation, when processed by the operation Processor, collects a snapshot of the entire Container metadata and serializes it to the ",Object(i.b)("em",{parentName:"p"},"Durable Data Log"),". This special operation marks a ",Object(i.b)("strong",{parentName:"p"},"Truncation Point")," - a place in the Stream of Log operations where we can issue Truncate operations. It is very important that after every truncation, the first operation to be found in the log is a ",Object(i.b)("inlineCode",{parentName:"p"},"MetadataCheckpointOperation"),", because without the prior operations to reconstruct metadata, this is the only way to be able to process subsequent operations."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note:")," ",Object(i.b)("em",{parentName:"p"},"Durable Data Log")," (Tier 1) truncation should not be confused with Segment Truncation. They serve different purposes and are applied to different targets."),Object(i.b)("h4",{id:"operation-processor"},"Operation Processor"),Object(i.b)("p",null,"The ",Object(i.b)("em",{parentName:"p"},"Operation Processor")," is a sub-component of the ",Object(i.b)("em",{parentName:"p"},"Durable Log")," that deals with incoming Log operations. Its purpose is to ",Object(i.b)("em",{parentName:"p"},"validate, persist"),", and ",Object(i.b)("em",{parentName:"p"},"update")," metadata and other internal structures based on the contents of each operation."),Object(i.b)("h4",{id:"operation-metadata-updater"},"Operation Metadata Updater"),Object(i.b)("p",null,"The ",Object(i.b)("em",{parentName:"p"},"Operation Metadata Updater")," is a sub-component of the ",Object(i.b)("em",{parentName:"p"},"Durable Log")," that is responsible with validating operations based on the current state of the metadata, as well as update the metadata after a successful commit of an operation. Internally it has various mechanisms to handle failures, and it can rollback certain changes in failure situations."),Object(i.b)("h4",{id:"durable-data-log"},"Durable Data Log"),Object(i.b)("p",null,"The ",Object(i.b)("em",{parentName:"p"},"Durable Data Log")," is an abstraction layer to an external component that provides append-only semantics. It is supposed to be a system which provides very fast appends to a log, that guarantees the durability and consistency of the written data. The read performance is not so much a factor, because we do not read directly from this component. Read is performed on it when we need to recover the contents of the ",Object(i.b)("em",{parentName:"p"},"Durable Log"),"."),Object(i.b)("p",null,"As explained above, Log operations are serialized into ",Object(i.b)("em",{parentName:"p"},"Data Frames")," (with a single operation able to span multiple such Frames if needed), and these ",Object(i.b)("em",{parentName:"p"},"Data Frames")," are then serialized as entries into this ",Object(i.b)("em",{parentName:"p"},"Durable Data Log"),". This is used only as a fail-safe, and we only need to read these Frames back if we need to perform recovery (in which case we need to deserialize all Log operations contained in them, in the same order in which they were received)."),Object(i.b)("h4",{id:"in-memory-operation-log"},"In-Memory Operation Log"),Object(i.b)("p",null,"The ",Object(i.b)("em",{parentName:"p"},"In-Memory Operation Log")," contains committed (and replicated) Log operations\xa0in the exact same order as they were added to the ",Object(i.b)("em",{parentName:"p"},"Durable Data Log"),". While the ",Object(i.b)("em",{parentName:"p"},"Durable Data Log")," contains a sequence of Data Frames (which contain serializations of operations), the Memory Log contains the actual operations, which can be used throughout the ",Object(i.b)("em",{parentName:"p"},"Durable Log")," and the Storage Writer."),Object(i.b)("p",null,"The Memory Log is essentially a chain of Log operations\xa0ordered by the time when the operation\xa0was received. We always add at one end, and we remove\xa0from the other. When we truncate the ",Object(i.b)("em",{parentName:"p"},"Durable Data Log")," the Memory Log is also truncated at the same location."),Object(i.b)("h3",{id:"read-index"},"Read Index"),Object(i.b)("p",null,"The ",Object(i.b)("em",{parentName:"p"},"Read Index")," helps the Segment Container perform reads from Streams at arbitrary offsets. While the ",Object(i.b)("em",{parentName:"p"},"Durable Log")," records (and can only replay) data in the order in which it is received, the ",Object(i.b)("em",{parentName:"p"},"Read Index")," can access the data in a random fashion. The ",Object(i.b)("em",{parentName:"p"},"Read Index")," is made of multiple ",Object(i.b)("em",{parentName:"p"},"Segment Read Indices")," (one per live Segment)."),Object(i.b)("p",null,"The\xa0",Object(i.b)("em",{parentName:"p"},"Segment Read Index"),"\xa0is a data structure that is used to serve reads from memory, as well as pull data from Tier 2 Storage and provides ",Object(i.b)("em",{parentName:"p"},"Future Reads")," (tail reads) when data is not yet available. When a read request is received, the ",Object(i.b)("em",{parentName:"p"},"Segment Read Index")," returns a read iterator that will return data as long as the read request parameters have not yet been satisfied. The iterator will either fetch data that is immediately available in memory, or request data from Tier 2 storage (and bring it to memory) or, if it reached the current end of the Segment, return a Future that will be completed when new data is added (thus providing tailing or future reads)."),Object(i.b)("p",null,"At the heart of the ",Object(i.b)("em",{parentName:"p"},"Segment Read Index")," lies a sorted index of entries (indexed by their start offsets) which is used to locate the requested data when needed. The index itself is implemented by a custom balanced binary search tree (AVL Tree to be more precise) with a goal of minimizing memory usage while not sacrificing insert or access performance. The entries themselves do not contain data, rather some small amount of metadata that is used to locate the data in the Cache and to determine usage patterns (good for cache evictions)."),Object(i.b)("h3",{id:"cache"},"Cache"),Object(i.b)("p",null,"The Cache is a component where all data (whether from new appends or that was pulled from Tier 2 storage) is stored. It is a direct memory store entirely managed by the Read Index."),Object(i.b)("h3",{id:"storage-writer"},"Storage Writer"),Object(i.b)("p",null,"Pravega is by no means the final resting place of the data, nor it is meant to be a storage service. The Tier 2 Storage is where we want data to be in the long term and Pravega is only used to store a very short tail-end of it (using Tier 1 Storage), enough to make appends fast and aggregate them into bigger chunks for committal to Tier 2 Storage. To perform this, it needs another component (",Object(i.b)("strong",{parentName:"p"},"Storage Writer"),") that reads data from the ",Object(i.b)("em",{parentName:"p"},"Durable Log")," in the order in which it was received, aggregates it, and sends it to Tier 2 Storage."),Object(i.b)("p",null,"Just like the ",Object(i.b)("em",{parentName:"p"},"Durable Log"),", there is one Storage Writer\xa0per Segment Container. Each Writer\xa0reads Log\xa0operations from the in-memory operation Log (exposed via the ",Object(i.b)("inlineCode",{parentName:"p"},"read()")," method in the ",Object(i.b)("em",{parentName:"p"},"Durable Log"),") in the order they were processed. It keeps track of the last read item by means of its sequence number. This state is not persisted, and upon recovery, it can just start from the beginning of the available ",Object(i.b)("em",{parentName:"p"},"Durable Log"),"."),Object(i.b)("p",null,"The Storage Writer can process any Storage operation (",Object(i.b)("em",{parentName:"p"},"Append, Seal, Merge"),"), and as Pravega being the sole actor it modifies such data in Tier 2 and applies them without any constraints. It has several mechanisms to detect and recover from possible data loss or external actors modifying data concurrently."),Object(i.b)("h1",{id:"integration-with-controller"},"Integration with Controller"),Object(i.b)("p",null,"Methods for mapping Segment Containers to hosts and rules used for moving from one to another are beyond the scope of this document. Here, we just describe how the Segment Store Service interacts with the ",Object(i.b)("em",{parentName:"p"},"Controller")," and how it manages the lifecycle of Segment Containers based on external events."),Object(i.b)("h2",{id:"segment-container-manager"},"Segment Container Manager"),Object(i.b)("p",null,"Each instance of a Segment Store Service needs a ",Object(i.b)("em",{parentName:"p"},"Segment Container Manager"),". The role of this component is to manage the lifecycle of the Segment Containers that are assigned to that node (service). It performs the following duties:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Connects to the Controller Service-Side Client (i.e., a client that deals only with Segment Container events, and not with the management of Streams and listens to all changes that pertain to Containers that pertain to its own instance."),Object(i.b)("li",{parentName:"ul"},"When it receives a notification that it needs to start a Segment Container for a particular Container Id, it initiates the process of bootstrapping such an object. It does not notify the requesting client of success until the operation completes without error."),Object(i.b)("li",{parentName:"ul"},"When it receives a notification that it needs to stop a Segment Container for a particular Container Id, it initiates the process of shutting it down. It does not notify the requesting client of success until the operation completes without error."),Object(i.b)("li",{parentName:"ul"},"If the Segment Container shuts down unexpectedly (whether during Start or during its normal operation), it will not attempt to restart it locally; instead it will notify the Controller.")),Object(i.b)("h1",{id:"storage-abstractions"},"Storage Abstractions"),Object(i.b)("p",null,"The Segment Store was not designed with particular implementations for Tier 1 or Tier 2. Instead, all these components have been abstracted out in simple, well-defined interfaces, which can be implemented against any standard file system (Tier 2) or append-only log system (Tier 1)."),Object(i.b)("p",null,"Possible candidates for Tier 1 Storage:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Apache BookKeeper")," (preferred, adapter is fully implemented as part of Pravega)"),Object(i.b)("li",{parentName:"ul"},"Non-durable, non-replicated solutions:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"In-Memory (Single node deployment only - Pravega becomes a volatile buffer for Tier 2 Storage; data loss is unavoidable and unrecoverable from in the case of process crash or system restart).",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"This is used for unit test only."))),Object(i.b)("li",{parentName:"ul"},"Local File System (Single node deployment only - Pravega becomes a semi-durable buffer for Tier 2 Storage; data loss is unavoidable and unrecoverable from in the case of complete node failure)")))),Object(i.b)("p",null,"Possible candidates for Tier 2 Storage:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"HDFS")," (Implementation available)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Extended S3")," (Implementation available)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"NFS")," (general ",Object(i.b)("strong",{parentName:"li"},"FileSystem"),") (Implementation available)"),Object(i.b)("li",{parentName:"ul"},"In-Memory (Single node deployment only - limited usefulness; data loss is unavoidable and unrecoverable from in the case of process crash or system restart)",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"This is used for unit test only.")))),Object(i.b)("p",null,"A note about ",Object(i.b)("strong",{parentName:"p"},"Tier 2 Truncation"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"The Segment Store supports Segment truncation at a particular offset, which means that, once that request is complete, no offset below that one will be available for reading."),Object(i.b)("li",{parentName:"ul"},"The above is a metadata update operation, however this also needs to be supported by Tier 2 so that the truncated data is physically deleted from it."),Object(i.b)("li",{parentName:"ul"},"If a Tier 2 implementation does not natively support truncation from the beginning of a file with offset preservation (i.e., a Segment of length 100 is truncated at offset 50, then offsets 0..49 are deleted, but offsets 50-99 are available and are not shifted down), then the ",Object(i.b)("strong",{parentName:"li"},"Segment Store")," provides a wrapper on top of a generic Tier 2 implementation that can do that."),Object(i.b)("li",{parentName:"ul"},"The ",Object(i.b)("inlineCode",{parentName:"li"},"RollingStorage")," Tier 2 wrapper splits a Segment into multiple ",Object(i.b)("em",{parentName:"li"},"Segment Chunks")," and exposes them as a single Segment to the upper layers. ",Object(i.b)("em",{parentName:"li"},"Segment Chunks")," that have been truncated out, are deleted automatically. This is not a very precise application (since it relies heavily on a rollover policy dictating granularity), but it is a practical solution for those cases when the real Tier 2 implementation does not provide the features that we need.  ")),Object(i.b)("h1",{id:"data-flow"},"Data Flow"),Object(i.b)("p",null,"Here are a few examples of how data flows inside the Pravega Segment Store Service."),Object(i.b)("h2",{id:"appends"},"Appends"),Object(i.b)("p",null,Object(i.b)("img",{alt:"Segment Store Appends",src:a(216).default})),Object(i.b)("p",null,"The diagram above depicts these steps (note the step numbers may not match, but the order is the same):"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("strong",{parentName:"li"},"Segment Store")," receives append request with params: Segment Name, Payload and Attribute Updates."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("strong",{parentName:"li"},"Segment Store")," determines the Container ID for the given Segment and verifies that the ",Object(i.b)("strong",{parentName:"li"},"Segment Container")," is registered locally. If not, it returns an appropriate error code."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("strong",{parentName:"li"},"Segment Store")," delegates request to the appropriate ",Object(i.b)("strong",{parentName:"li"},"Segment Container")," instance.",Object(i.b)("ol",{parentName:"li"},Object(i.b)("li",{parentName:"ol"},Object(i.b)("strong",{parentName:"li"},"Segment Container")," verifies that the Segment belongs to the Segment Container and that the Segment actually exists. If not, it returns an appropriate error code.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"During this process, it also gets an existing Segment ID or assigns a new one (by using the ",Object(i.b)("strong",{parentName:"li"},"Segment Mapper")," component)."))),Object(i.b)("li",{parentName:"ol"},"Segment Container creates a ",Object(i.b)("inlineCode",{parentName:"li"},"StreamSegmentAppendOperation")," with the input data and sends it to the ",Object(i.b)("em",{parentName:"li"},"Durable Log"),"."))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("strong",{parentName:"li"},"Durable Log")," takes the Append operation and processes it according to the algorithm described in the\xa0",Object(i.b)("a",{parentName:"li",href:"#durable-log"},"Durable Log")," section.  ",Object(i.b)("ol",{parentName:"li"},Object(i.b)("li",{parentName:"ol"},"Puts it in its operation Queue."),Object(i.b)("li",{parentName:"ol"},"Operation Processor pulls all operations off the Queue."),Object(i.b)("li",{parentName:"ol"},"Operation Processor uses the ",Object(i.b)("em",{parentName:"li"},"Data Frame Builder")," to construct ",Object(i.b)("em",{parentName:"li"},"Data Frames")," with the operations it has."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("em",{parentName:"li"},"Data Frame Builder")," asynchronously writes the ",Object(i.b)("em",{parentName:"li"},"Data Frame")," to the ",Object(i.b)("em",{parentName:"li"},"Durable Data Log"),"."),Object(i.b)("li",{parentName:"ol"},"Upon completion, the following are done in parallel:",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Metadata is updated."),Object(i.b)("li",{parentName:"ul"},"The operation is added to the ",Object(i.b)("em",{parentName:"li"},"Memory Operation Log")," and ",Object(i.b)("em",{parentName:"li"},"Read Index"),"."),Object(i.b)("li",{parentName:"ul"},"A call that triggered the operation is acked."))),Object(i.b)("li",{parentName:"ol"},"The above process is asynchronous, which means the Operation Processor will have multiple ",Object(i.b)("em",{parentName:"li"},"Data Frames")," in flight (not illustrated). It will keep track of each one's changes and apply or roll them back as needed.")))),Object(i.b)("p",null,"This process applies for every single operation that the ",Object(i.b)("strong",{parentName:"p"},"Segment Store")," supports. All ",Object(i.b)("em",{parentName:"p"},"modify")," operations go through the Operation Processor and have a similar path."),Object(i.b)("h2",{id:"reads"},"Reads"),Object(i.b)("p",null,Object(i.b)("img",{alt:"Segment Store Reads",src:a(217).default})),Object(i.b)("p",null,"The diagram above depicts these steps (note the step numbers may not match, but the order is the same):"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("strong",{parentName:"li"},"Segment Store")," receives read request with params: Segment Name, Read Offset, Max-Length.",Object(i.b)("ol",{parentName:"li"},Object(i.b)("li",{parentName:"ol"},Object(i.b)("strong",{parentName:"li"},"Segment Store")," determines the Container ID for the given Segment and verifies if it is Leader for given ",Object(i.b)("strong",{parentName:"li"},"Segment Container"),". If not, it returns an appropriate error code."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("strong",{parentName:"li"},"Segment Store")," delegates request to the ",Object(i.b)("strong",{parentName:"li"},"Segment Container")," instance."))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("strong",{parentName:"li"},"Segment Container")," verifies that the Segment belongs to that Container and that it actually exists. If not, it returns an appropriate error code to the client.",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"During this process, it also gets an existing Segment ID or assigns a new one (by using the ",Object(i.b)("strong",{parentName:"li"},"Segment Mapper")," component)."))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("strong",{parentName:"li"},"Segment Container")," delegates the request to its ",Object(i.b)("em",{parentName:"li"},"Read Index"),", which processes the read as described in the ",Object(i.b)("a",{parentName:"li",href:"#read-index"},"Read Index")," section, by issuing Reads from ",Object(i.b)("strong",{parentName:"li"},"Storage")," (for data that is not in the ",Object(i.b)("strong",{parentName:"li"},"Cache"),"), and querying/updating the ",Object(i.b)("strong",{parentName:"li"},"Cache")," as needed.")),Object(i.b)("h2",{id:"synchronization-with-tier-2-storage-writer"},"Synchronization with Tier 2 (Storage Writer)"),Object(i.b)("p",null,Object(i.b)("img",{alt:"Segment Store Sync Tier 2",src:a(218).default})),Object(i.b)("p",null,"The diagram above depicts these steps (note the step numbers may not match, but the order is the same):"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"The ",Object(i.b)("strong",{parentName:"li"},"Storage Writer"),"'s main loop is the sub-component that triggers all these operations."),Object(i.b)("li",{parentName:"ol"},"Read next operation from the ",Object(i.b)("em",{parentName:"li"},"Durable Log")," (in between each loop, the Writer remembers what the sequence number of the last processed operation was)."),Object(i.b)("li",{parentName:"ol"},"All operations are processed and added to the internal ",Object(i.b)("strong",{parentName:"li"},"Segment Aggregators")," (one Aggregator per Segment)."),Object(i.b)("li",{parentName:"ol"},"Eligible Segment Aggregators are flushed to ",Object(i.b)("strong",{parentName:"li"},"Storage")," (eligibility depends on the amount of data collected in each aggregator, and whether there are any Seal, Merge or Truncate operations queued up).",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"Each time an Append operation is encountered, a trip to the ",Object(i.b)("em",{parentName:"li"},"Read Index")," may be required in order to get the contents of the append."))),Object(i.b)("li",{parentName:"ol"},"After every successful modification (",Object(i.b)("em",{parentName:"li"},"write/seal/concat/truncate"),") to ",Object(i.b)("strong",{parentName:"li"},"Storage"),", the ",Object(i.b)("strong",{parentName:"li"},"Container Metadata")," is updated to reflect the changes."),Object(i.b)("li",{parentName:"ol"},"The ",Object(i.b)("em",{parentName:"li"},"Durable Log")," is truncated (if eligible).")),Object(i.b)("h2",{id:"container-startup-normalrecovery"},"Container Startup (Normal/Recovery)"),Object(i.b)("p",null,Object(i.b)("img",{alt:"Segment Store Container Startup",src:a(219).default})),Object(i.b)("p",null,"The diagram above depicts these steps (note the step numbers may not match, but the order is the same):"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"The ",Object(i.b)("strong",{parentName:"li"},"Container Manager")," receives a request to start a Container in this instance of the ",Object(i.b)("strong",{parentName:"li"},"Segment Store Service"),".",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"It creates, registers, and starts the Container."))),Object(i.b)("li",{parentName:"ol"},"The ",Object(i.b)("strong",{parentName:"li"},"Container")," starts the ",Object(i.b)("em",{parentName:"li"},"Durable Log")," component."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("em",{parentName:"li"},"Durable Log")," initiates the recovery process (coordinated by the ",Object(i.b)("strong",{parentName:"li"},"Recovery Executor"),")."),Object(i.b)("li",{parentName:"ol"},Object(i.b)("strong",{parentName:"li"},"Recovery Executor")," reads all ",Object(i.b)("em",{parentName:"li"},"Data Frames")," from ",Object(i.b)("em",{parentName:"li"},"Durable Data Log"),"."),Object(i.b)("li",{parentName:"ol"},"Deserialized operations from the read ",Object(i.b)("em",{parentName:"li"},"Data Frames")," are added to the ",Object(i.b)("strong",{parentName:"li"},"Memory Operation Log"),"."),Object(i.b)("li",{parentName:"ol"},"The ",Object(i.b)("strong",{parentName:"li"},"Container Metadata")," is updated by means of the ",Object(i.b)("strong",{parentName:"li"},"Operation Metadata Updater")," (same as the one used inside Operation Processor)."),Object(i.b)("li",{parentName:"ol"},"The ",Object(i.b)("em",{parentName:"li"},"Read Index")," is populated with the contents of those operations that apply to it."),Object(i.b)("li",{parentName:"ol"},"The ",Object(i.b)("strong",{parentName:"li"},"Container")," Starts the ",Object(i.b)("strong",{parentName:"li"},"Storage Writer"),".",Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"The ",Object(i.b)("strong",{parentName:"li"},"Storage Writer"),"'s Main Loop starts processing operations from the ",Object(i.b)("em",{parentName:"li"},"Durable Log"),", and upon first encountering a new Segment, it reconciles its content (and metadata) with the reality that exists in ",Object(i.b)("strong",{parentName:"li"},"Storage"),"."))),Object(i.b)("li",{parentName:"ol"},"After both the ",Object(i.b)("strong",{parentName:"li"},"Durable Log")," and the ",Object(i.b)("strong",{parentName:"li"},"Storage Writer")," have started, the ",Object(i.b)("strong",{parentName:"li"},"Container")," is ready to start accepting new external requests.")))}c.isMDXComponent=!0},147:function(e,t,a){"use strict";a.d(t,"a",(function(){return m})),a.d(t,"b",(function(){return h}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var b=r.a.createContext({}),c=function(e){var t=r.a.useContext(b),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=c(e.components);return r.a.createElement(b.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,b=l(e,["components","mdxType","originalType","parentName"]),m=c(a),d=n,h=m["".concat(o,".").concat(d)]||m[d]||p[d]||i;return a?r.a.createElement(h,s(s({ref:t},b),{},{components:a})):r.a.createElement(h,s({ref:t},b))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,o[1]=s;for(var b=2;b<i;b++)o[b]=a[b];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,a)}d.displayName="MDXCreateElement"},215:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/Segment-store-components-711591d6b64b575fa80c8a4dc3f33417.png"},216:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/segment-store-append-00ad0f792356573419bbce79d897d1e3.png"},217:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/segment-store-reads-7392946bc98ad7edcbe07c8ff3d548c5.png"},218:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/segment-store-synctier2-b7676e70c2e313dce7c78be5a4f1b3e4.png"},219:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/segment-store-recovery-47bbea320bc338b23802f694cfc7278d.png"}}]);