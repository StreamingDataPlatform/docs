(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{140:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return s})),a.d(t,"toc",(function(){return c})),a.d(t,"default",(function(){return m}));var n=a(3),r=a(7),i=(a(0),a(168)),o={title:"StreamCuts"},s={unversionedId:"pravega/streamcuts",id:"pravega/streamcuts",isDocsHomePage:!1,title:"StreamCuts",description:"\x3c!--",source:"@site/docs/pravega/streamcuts.md",slug:"/pravega/streamcuts",permalink:"/docs/docs/pravega/streamcuts",editUrl:"https://github.com/claudiofahey/pravega/edit/docusaurus/documentation/src/docs/streamcuts.md",version:"current",sidebar:"mainSidebar",previous:{title:"Transactions",permalink:"/docs/docs/pravega/transactions"},next:{title:"Pravega Deployment Overview",permalink:"/docs/docs/pravega/deployment/deployment"}},c=[{value:"Pre-requisites",id:"pre-requisites",children:[]},{value:"Definition",id:"definition",children:[]},{value:"StreamCut with Reader",id:"streamcut-with-reader",children:[]},{value:"StreamCut with Stream Manager",id:"streamcut-with-stream-manager",children:[]},{value:"StreamCut with BatchClient",id:"streamcut-with-batchclient",children:[]}],p={toc:c};function m(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},p,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"This section describes ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut"),"s and its usage with streaming clients and batch clients."),Object(i.b)("h2",{id:"pre-requisites"},"Pre-requisites"),Object(i.b)("p",null,"Familiarity with ",Object(i.b)("a",{parentName:"p",href:"/docs/docs/pravega/pravega-concepts"},"Pravega Concepts"),"."),Object(i.b)("h2",{id:"definition"},"Definition"),Object(i.b)("p",null,"A Pravega Stream is formed by one or multiple parallel Stream Segments for storing/reading events. A Pravega Stream\nis elastic, as it handles the changes in the number of parallel Stream Segments along time to accommodate\nfluctuating workloads. A ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut")," represents a consistent position in the stream. It contains\na set of Stream Segments and offset pairs for a single stream which represents the complete keyspace at a given\npoint in time. The offset always points to the event boundary and hence there will be no offset pointing to\nan incomplete event."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut")," representing the tail of the stream (with the newest event) is an ever changing one since\nevents can be continuously added to the stream and the ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut")," pointing to the tail of the stream with\nnewer events would have a different value. Similarly the ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut")," representing the head of the\nstream (with the oldest event) is an ever changing one as the stream retention policy could truncate the stream\nand the ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut")," pointing to the head of the stream post truncation would have a different value.\n",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut.UNBOUNDED")," is used to represent such a position in the stream and the user can use it to\nspecify this ever changing stream position (both head and tail of the stream)."),Object(i.b)("p",null,"It should be noted that ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut"),"s obtained using the streaming client and batch client can be used\ninterchangeably."),Object(i.b)("h2",{id:"streamcut-with-reader"},"StreamCut with Reader"),Object(i.b)("p",null,"A Reader Group is a named collection of Readers that together, in parallel, read Events from a given stream. Every\nReader is always associated with a Reader Group. ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut"),"(s) can be obtained from a Reader Group using the\nfollowing APIs:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"getStreamCuts()"),": The API ",Object(i.b)("inlineCode",{parentName:"p"},"io.pravega.client.stream.ReaderGroup.getStreamCuts")," returns a\n",Object(i.b)("inlineCode",{parentName:"p"},"Map<Stream, StreamCut>")," which represents the ",Object(i.b)("strong",{parentName:"p"},"last known Position of the Readers")," for all the streams managed by the Reader Group.")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"generateStreamCuts()"),": The API ",Object(i.b)("inlineCode",{parentName:"p"},"io.pravega.client.stream.ReaderGroup.generateStreamCuts"),", generates a ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut")," after co-ordinating with all the Readers using ",Object(i.b)("inlineCode",{parentName:"p"},"io.pravega.client.state.StateSynchronizer"),". A ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut")," is generated by using the latest Stream Segment read offsets returned by the Readers along with unassigned segments (if any). The configuration ",Object(i.b)("inlineCode",{parentName:"p"},"ReaderGroupConfig.getGroupRefreshTimeMillis()")," decides the maximum delay by which the Readers return the latest read offsets of their assigned segments. The ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut")," generated by this API can be used by the application as a reference to a Position in the stream. This is guaranteed to be greater than or equal to the position of the Readers at the point of invocation of the API."))),Object(i.b)("p",null,"A ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut")," can be used to configure a Reader Group to enable bounded processing of a Stream. The start\nand/or end ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut")," of a Stream can be passed as part of the Reader Group configuration. The below example\nshows the different ways to use ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut"),"s as part of the Reader Group configuration."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},'/*\n * The below ReaderGroup configuration ensures that the readers belonging to\n * the ReaderGroup read events from\n *   - Stream "s1" from startStreamCut1 (representing the oldest event) upto\n          endStreamCut1 (representing the newest event)\n *   - Stream "s2" from startStreamCut2 upto the tail of the stream, this is similar to using StreamCut.UNBOUNDED\n *        for endStreamCut.\n *   - Stream "s3" from the current head of the stream upto endStreamCut2\n *   - Stream "s4" from the current head of the stream upto the tail of the stream.\n */\nReaderGroupConfig.builder()\n                .stream("scope/s1", startStreamCut1, endStreamCut1)\n                .stream("scope/s2", startStreamCut2)\n                .stream("scope/s3", StreamCut.UNBOUNDED, endStreamCut2)\n                .stream("scope/s4")\n                .build();\n')),Object(i.b)("p",null,"The below API can be used to reset an existing Reader Group with a new Reader Group configuration instead creating a Reader Group."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"/*\n * ReaderGroup API used to reset a ReaderGroup to a newer ReaderGroup configuration.\n */\nio.pravega.client.stream.ReaderGroup.resetReaderGroup(ReaderGroupConfig config)\n")),Object(i.b)("h2",{id:"streamcut-with-stream-manager"},"StreamCut with Stream Manager"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"StreamCut")," representing the current head and current tail of a stream can be obtained using the ",Object(i.b)("inlineCode",{parentName:"p"},"StreamManager")," API ",Object(i.b)("inlineCode",{parentName:"p"},"getStreamInfo(String scopeName, String streamName)"),"."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"/**\n\n     * Get information about a given Stream, {@link StreamInfo}.\n     * This includes {@link StreamCut}s pointing to the current HEAD and TAIL of the Stream.\n     *\n     * @param scopeName The scope of the stream.\n     * @param streamName The stream name.\n     * @return stream information.\n     */\n    StreamInfo getStreamInfo(String scopeName, String streamName);\n\n")),Object(i.b)("h2",{id:"streamcut-with-batchclient"},"StreamCut with BatchClient"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"BatchClient")," can be used to perform bounded processing of the stream given the start and end ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut"),"s. ",Object(i.b)("inlineCode",{parentName:"p"},"BatchClient")," API ",Object(i.b)("inlineCode",{parentName:"p"},"io.pravega.client.batch.BatchClient.getSegments(stream, startStreamCut, endStreamCut)")," is used to\nfetch segments which reside between the given ",Object(i.b)("inlineCode",{parentName:"p"},"startStreamCut")," and ",Object(i.b)("inlineCode",{parentName:"p"},"endStreamCut"),". With the retrieved segment information, the user can consume all the events in parallel without adhering to time ordering of events."),Object(i.b)("p",null,"It must be noted that passing ",Object(i.b)("inlineCode",{parentName:"p"},"StreamCut.UNBOUNDED")," to ",Object(i.b)("inlineCode",{parentName:"p"},"startStreamCut")," and ",Object(i.b)("inlineCode",{parentName:"p"},"endStreamCut")," will result in using the current head of stream and the current tail of the stream, respectively."),Object(i.b)("p",null,"We have provided a simple yet illustrative example of using StreamCut\xa0",Object(i.b)("a",{parentName:"p",href:"https://github.com/pravega/pravega-samples/tree/v0.5.0/pravega-client-examples/src/main/java/io/pravega/example/streamcuts"},"here"),"."))}m.isMDXComponent=!0},168:function(e,t,a){"use strict";a.d(t,"a",(function(){return u})),a.d(t,"b",(function(){return b}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=r.a.createContext({}),m=function(e){var t=r.a.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=m(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=m(a),d=n,b=u["".concat(o,".").concat(d)]||u[d]||l[d]||i;return a?r.a.createElement(b,s(s({ref:t},p),{},{components:a})):r.a.createElement(b,s({ref:t},p))}));function b(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:n,o[1]=s;for(var p=2;p<i;p++)o[p]=a[p];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,a)}d.displayName="MDXCreateElement"}}]);