(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{160:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return s})),a.d(t,"toc",(function(){return l})),a.d(t,"default",(function(){return p}));var n=a(3),r=a(7),i=(a(0),a(169)),o={title:"State Synchronizer"},s={unversionedId:"pravega/state-synchronizer",id:"pravega/state-synchronizer",isDocsHomePage:!1,title:"State Synchronizer",description:"\x3c!--",source:"@site/docs/pravega/state-synchronizer.md",slug:"/pravega/state-synchronizer",permalink:"/docs/docs/pravega/state-synchronizer",editUrl:"https://github.com/claudiofahey/pravega/edit/docusaurus/documentation/src/docs/state-synchronizer.md",version:"current",sidebar:"mainSidebar",previous:{title:"Basic Reader and Writer",permalink:"/docs/docs/pravega/basic-reader-and-writer"},next:{title:"Transactions",permalink:"/docs/docs/pravega/transactions"}},l=[{value:"Shared State and Pravega",id:"shared-state-and-pravega",children:[]},{value:"SharedStateMap and Shared Configuration Example",id:"sharedstatemap-and-shared-configuration-example",children:[]},{value:"Using State Synchronizer to Build the SharedMap",id:"using-state-synchronizer-to-build-the-sharedmap",children:[{value:"State Synchronizer",id:"state-synchronizer",children:[]},{value:"StateT",id:"statet",children:[]},{value:"UpdateT and InitialUpdateT",id:"updatet-and-initialupdatet",children:[]}]},{value:"Executing Operations on SharedMap",id:"executing-operations-on-sharedmap",children:[{value:"Create/Initialize\xa0",id:"createinitialize",children:[]},{value:"Read Operations",id:"read-operations",children:[]},{value:"Write (update) Operations",id:"write-update-operations",children:[]},{value:"Delete Operations",id:"delete-operations",children:[]}]}],c={toc:l};function p(e){var t=e.components,o=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},c,o,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"You can think about Pravega as a streaming storage primitive, because it is a\ngreat way to durably persist data. \xa0You can think about Pravega as a great\npub-sub messaging system, because with Readers, Writers and ReaderGroups it is a\ngreat way to do messaging at scale. \xa0But you can also think about Pravega as a\nway to implement shared state in a consistent fashion across multiple\ncooperating processes distributed in a cluster. \xa0It is this latter category that\nwe explore with this document."),Object(i.b)("p",null,"Instructions for running the sample applications can be found in the",Object(i.b)("a",{parentName:"p",href:"https://github.com/pravega/pravega-samples/blob/v0.5.0/pravega-client-examples/README.md"},"\xa0Pravega\nSamples\nreadme"),"."),Object(i.b)("p",null,"You really should be familiar with Pravega Concepts (see\xa0",Object(i.b)("a",{parentName:"p",href:"/docs/docs/pravega/pravega-concepts"},"Pravega\nConcepts"),") before continuing reading this page.\n\xa0In particular, you should be somewhat familiar with the ",Object(i.b)("a",{parentName:"p",href:"/docs/docs/pravega/pravega-concepts#state-synchronizers"},"State\nSynchronizer"),"\nconcept."),Object(i.b)("h2",{id:"shared-state-and-pravega"},"Shared State and Pravega"),Object(i.b)("p",null,"State Synchronizer is a facility provided by the Pravega programming model to\nmake it easy for developers to use Pravega to coordinate shared state between\nprocesses."),Object(i.b)("p",null,Object(i.b)("img",{alt:"state synchronizer",src:a(183).default})),Object(i.b)("p",null,"The idea is that a Stream is used to persist a sequence of changes to shared\nstate and that various applications use their Pravega Java Client Library to\nconcurrently read and write the shared state in a consistent fashion.\xa0"),Object(i.b)("h2",{id:"sharedstatemap-and-shared-configuration-example"},"SharedStateMap and Shared Configuration Example"),Object(i.b)("p",null,"Before we dive into the details about how to use State Synchronizer, let's take\na quick look at an example application that uses State Synchronizer. \xa0We have\nprovided a simple yet illustrative example of using State\nSynchronizer\xa0",Object(i.b)("a",{parentName:"p",href:"https://github.com/pravega/pravega-samples/tree/v0.5.0/pravega-client-examples/src/main/java/io/pravega/example/statesynchronizer"},"here.")),Object(i.b)("p",null,"The example uses State Synchronizer to build an implementation of Java's Map\ndata structure called SharedMap. \xa0We use that primitive SharedMap data structure\nto build a Shared Config, that allows a set of processes to consistently\nread/write a shared, configuration object of key/value pair properties. \xa0Also as\npart of that example, we provide a simple command line-based application that\nallows you to play around with the SharedConfig app."),Object(i.b)("p",null,Object(i.b)("img",{alt:"state synchronizer example",src:a(247).default})),Object(i.b)("p",null,"Here is a menu of the available commands in the SharedConfigCLI application:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"Enter one of the following commands at the command line prompt:\n\nGET_ALL - prints out all of the properties in the Shared Config.\nGET {key} - print out the configuration property for the given key.\nPUT {key} , {value} - update the Shared Config with the given key/value pair.  Print out previous value (if it existed).\nPUT_IF_ABSENT {key} , {value} - update the Shared Config with the given key/value pair, only if the property is not already defined.\nREMOVE {key} [ , {currentValue}] - remove the given property from the Shared Config.  If {currentValue} is given, remove only if the property's current value matches {currentValue}..\nREPLACE {key} , {newValue} [ , {currentValue}] - update the value of the property.  If {currentValue} is given, update only if the property's current value matches {cuurentValue}.\nCLEAR - remove all the keys from the Shared Config.\nREFRESH - force an update from the Synchronized State.\nHELP - print out a list of commands.\nQUIT - terminate the program.\n")),Object(i.b)("p",null,"Install the Pravega-Samples and launch two instances of the SharedConfigCLI\nusing the same scope and stream name. \xa0This will simulate how two different\nprocesses can coordinate their local copy of the SharedConfig with one shared\nstate object. \xa0You can follow these steps to get a feel for how the SharedConfig\nis coordinated:"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"th"},"#")),Object(i.b)("th",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"th"},"Process 1")),Object(i.b)("th",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"th"},"Process 2")),Object(i.b)("th",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"th"},"Discussion")))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"1"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"td"},"GET","_","ALL")),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"td"},"GET","_","ALL")),Object(i.b)("td",{parentName:"tr",align:null},"Shows that both processes see an empty SharedConfig")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"2"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"td"},"PUT")," p1,v1"),Object(i.b)("td",{parentName:"tr",align:null}),Object(i.b)("td",{parentName:"tr",align:null},"Process 1 adds a property named p1")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"3"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"td"},"GET")," p1"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"td"},"GET")," p1"),Object(i.b)("td",{parentName:"tr",align:null},"Process 1 sees value v1 for the property")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null}),Object(i.b)("td",{parentName:"tr",align:null}),Object(i.b)("td",{parentName:"tr",align:null}),Object(i.b)("td",{parentName:"tr",align:null},"Process 2 does not have a property named p1. Why? Because it has not refreshed its state with the shared state")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"4"),Object(i.b)("td",{parentName:"tr",align:null}),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"td"},"REFRESH")),Object(i.b)("td",{parentName:"tr",align:null},"Re-synchronize Process 2's state with the shared state")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"5"),Object(i.b)("td",{parentName:"tr",align:null}),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"td"},"GET")," p1"),Object(i.b)("td",{parentName:"tr",align:null},"Now Process 2 sees the change Process 1 made in step 2")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"6"),Object(i.b)("td",{parentName:"tr",align:null}),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"td"},"REPLACE")," p1, newVal, v1"),Object(i.b)("td",{parentName:"tr",align:null},"Process 2 attempts to change the value of p1, but uses a conditional replace, meaning the change should be made only if the old value of p1 is v1 (which it is at this point)")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"7"),Object(i.b)("td",{parentName:"tr",align:null}),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"td"},"GET")," p1"),Object(i.b)("td",{parentName:"tr",align:null},"Sure enough, the value of p1 was changed to newVal")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"8"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"td"},"REPLACE")," p1, anotherVal, v1"),Object(i.b)("td",{parentName:"tr",align:null}),Object(i.b)("td",{parentName:"tr",align:null},"Process 1 tries to change the value of p1 in the same way Process 2 did in step 6. This will fail because the value of p1 in shared state is no longer v1")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"9"),Object(i.b)("td",{parentName:"tr",align:null},Object(i.b)("strong",{parentName:"td"},"GET")," p1"),Object(i.b)("td",{parentName:"tr",align:null}),Object(i.b)("td",{parentName:"tr",align:null},"The failed replace operation in step 8 caused Process 1's copy of the shared state to be updated, its value is now newVal because of step 6.")))),Object(i.b)("p",null,"You can repeat with a similar sequence to explore the semantics of\nPUT","_","IF","_","ABSENT and other operations that modify shared state."),Object(i.b)("p",null,"The idea is that modifications to the SharedConfig succeed only if they operate\non the latest value. \xa0We use optimistic concurrency to implement efficient\nconsistency across multiple consumers of the SharedConfig object."),Object(i.b)("p",null,"You can have multiple different SharedConfig state objects running\nsimultaneously, each separate SharedConfig uses State Synchronizer objects based\non a different Pravega Stream. \xa0Of course if you launch two applications using\nState Synchronizer objects backed by the same Stream, you get two processes\nconcurrently accessing the shared state. \xa0This is exactly the situation we\nillustrated above."),Object(i.b)("h2",{id:"using-state-synchronizer-to-build-the-sharedmap"},"Using State Synchronizer to Build the SharedMap"),Object(i.b)("p",null,"We used the State Synchronizer to build the SharedMap object in Pravega-Samples.\n\xa0State Synchronizer can be used to build a shared version of almost any data\nstructure. \xa0Maybe your app needs to share just a simple integer count of\nsomething; we can use State Synchronizer to build a simple shared counter.\n\xa0Maybe the data you are sharing is a Set of currently running servers in a\ncluster; \xa0we can use State Synchronizer to build \xa0a shared Set. \xa0The\npossibilities are many."),Object(i.b)("p",null,"Let's explore how to build shared objects using State Synchronizer by examining\nhow we built Shared Map."),Object(i.b)("h3",{id:"state-synchronizer"},"State Synchronizer"),Object(i.b)("p",null,"State Synchronizer is a type of Pravega client, similar to an EventStreamReader\nor EventStreamWriter. \xa0A State Synchronizer is created via a ClientFactory\nobject. \xa0Each State Synchronizer has a unique name within a Scope. \xa0A\nSynchronizerConfig object is used to tailor the behavior of a StateSynchronizer\n(although currently, there are no properties on a State Synchronizer that are\nconfigurable). \xa0State Synchronizer uses Java generic types to allow a developer\nto specify a type specific State Synchronizer. \xa0All of these things are done in\na fashion similar to how EventStreamReaders and EventStreamWriters are used."),Object(i.b)("h3",{id:"statet"},"StateT"),Object(i.b)("p",null,'When designing an application that uses State Synchronizer, the developer needs\nto decide what type of state is going to be synchronized (shared). \xa0Are we\nsharing a Map? \xa0A Set? \xa0A Pojo? What is the data structure that is being shared.\n\xa0This defines the core "type" of the State Synchronizer (the StateT generic type\nin the State Synchronizer interface). \xa0The StateT object can be any Java object\nthat implements the ',Object(i.b)("em",{parentName:"p"},"Revisioned")," interface defined by Pravega. \xa0",Object(i.b)("em",{parentName:"p"},"Revisioned")," is\na simple interface that allows Pravega to ensure it can properly compare two\ndifferent StateT objects."),Object(i.b)("p",null,"In our example, the SharedMap is the State Synchronizer application. \xa0It defines\na simple Map object presenting the typical get(key), set (key, value) etc.\noperations you would expect from a key-value pair map object. \xa0It\nimplements\xa0\xa0the\xa0",Object(i.b)("em",{parentName:"p"},"Revisioned"),"\xa0interface, as required to use the State\nSynchronizer, and uses a simple ConcurrentHashMap as its internal implementation\nof the Map. \xa0So in our example, StateT corresponds to SharedStateMap\\<K,V",">","."),Object(i.b)("h3",{id:"updatet-and-initialupdatet"},"UpdateT and InitialUpdateT"),Object(i.b)("p",null,'In addition to StateT, there are two other generic types that need to be defined\nby a StateSynchronizer app: an Update type and an InitialUpdate type). \xa0The\nUpdateType represents the "delta" or change objects that are persisted on the\nPravega Stream. \xa0The InitialUpdateType is a special update object used to to\nstart the State Synchronizer off. \xa0Both UpdateType and InitialUpdateType are\ndefined in terms of StateT.'),Object(i.b)("p",null,"The StateSynchronizer uses a single Segment on a Stream to store updates\n(changes) to the shared state object. \xa0Changes, in the form of Initial or Update\ntype objects, are written to the Stream based on whether the update is relative\nto the most current copy of the state in the Stream. \xa0If an update is presented\nthat is based on an older version of the state, the update is not made."),Object(i.b)("p",null,"The StateSynchronizer object itself keeps a local in memory copy of the state,\nit also keeps version metadata about that copy of the state. \xa0Local state can be\nretrieved using the getState() operation. \xa0The local in memory copy could be\nstale, and it can be refreshed by an application using the fetchUpdates()\noperation, that retrieves all the changes made to the given version of the\nstate."),Object(i.b)("p",null,"Most changes from the application are made through the updateState() operation.\n\xa0The updateState() operation takes a Function as parameter. \xa0The Function is\ninvoked with the latest state object, and computes the updates to be applied."),Object(i.b)("p",null,"In our example, InitialUpdateT is implemented as:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"/**\n * Create a Map. This is used by StateSynchronizer to initialize shared state.\n */\nprivate static class CreateState<K, V> implements InitialUpdate<SharedStateMap<K,V>>, Serializable {\n    private static final long serialVersionUID = 1L;\n    private final ConcurrentHashMap<K, V> impl;\n\n    public CreateState(ConcurrentHashMap<K, V> impl) {\n        this.impl = impl;\n    }\n\n    @Override\n    public SharedStateMap<K, V> create(String scopedStreamName, Revision revision) {\n        return new SharedStateMap<K, V>(scopedStreamName, impl, revision);\n    }\n}\n")),Object(i.b)("p",null,"In this case, the CreateState class is used to initialize the shared state in\nthe Stream by creating a new, empty SharedStateMap object. \xa0You could imagine\nother examples of InitialUpdate that would set a counter to 1, or perhaps\ninitialize a Set to a fixed initial set of members."),Object(i.b)("p",null,'It may seem a bit odd that functions like "initialize" and "update" are\nexpressed as classes, but when you think about it, that makes sense. \xa0The\nchanges, like initialize and update, need to be stored in Pravega, therefore\nthey need to be serializable objects. \xa0It must be possible for client\napplications to be able to start at any time, compute the current state and then\nkeep up as changes are written to the Stream. \xa0If we just stored "the latest\nstate value" in the Stream, there would be no way to consistently provide\nconcurrent update and read using optimistic concurrency.'),Object(i.b)("p",null,'UpdateT is a bit more tricky. \xa0There isn\'t just one kind of update to a Map, but\nrather there are all sorts of updates: put of a key/value pair, put of a\ncollection of key/value pairs, removing a key/value pair and clearing all of the\nkey/value pairs, \xa0Each of these "kinds" of updates are represented by their own\nClass. \xa0We define an abstract class, called StateUpdate, from which all of these\n"operational" update classes inherit. \xa0'),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"StateUpdate abstract class")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"/**\n * A base class for all updates to the shared state. This allows for several different types of updates.\n */\nprivate static abstract class StateUpdate<K,V> implements Update<SharedStateMap<K,V>>, Serializable {\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public SharedStateMap<K,V> applyTo(SharedStateMap<K,V> oldState, Revision newRevision) {\n        ConcurrentHashMap<K, V> newState = new ConcurrentHashMap<K, V>(oldState.impl);\n        process(newState);\n        return new SharedStateMap<K,V>(oldState.getScopedStreamName(), newState, newRevision);\n    }\n\n    public abstract void process(ConcurrentHashMap<K, V> updatableList);\n}\n")),Object(i.b)("p",null,'By defining an abstract class, we can define UpdateT in terms of the abstract\nStateUpdate class. \xa0The abstract class implements the "applyTo" method that is\ninvoked by the StateSynchronizer to apply the update to the current state object\nand return an updated state object. \xa0The actual work is done on a copy of the\nold state\'s underlying Map (impl) object, a "process" operation is applied\n(specific to each subclass) to the impl object and a new version of the\nSharedState, using the post-processed impl as the internal state. \xa0The abstract\nclass defines a process() method that actually does the work of whatever update\nneeds to be applied. \xa0This method is implemented by the various concrete classes\nthat represent Put, PutAll etc. operations on the shared map.'),Object(i.b)("p",null,"Here, for example, is the way we implement the Put(key,value) operation on the\nSharedMap object:"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Put as an Update Object")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"/**\n * Add a key/value pair to the State.\n */\nprivate static class Put<K,V> extends StateUpdate<K,V> {\n    private static final long serialVersionUID = 1L;\n    private final K key;\n    private final V value;\n\n    public Put(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    @Override\n    public void process(ConcurrentHashMap<K, V> impl) {\n        impl.put(key, value);\n    }\n}\n")),Object(i.b)("p",null,'Here, the process() operation is to add a key/value pair to the map, or if the\nkey already exists, change the value. \xa0Each of the "operations" on the SharedMap\nis implemented in terms of creating instances of the various subclasses of\nStateUpdate.'),Object(i.b)("h2",{id:"executing-operations-on-sharedmap"},"Executing Operations on SharedMap"),Object(i.b)("p",null,"SharedMap demonstrates the typical operations on a StateSynchronizer. \xa0SharedMap\npresents an API, very similar to Java's Map\\<K,V",">"," interface. \xa0It implements the\nMap operations in terms of manipulating the StateSynchronizer, using the various\nsubclasses of StateUpdate to perform state change (write) operations."),Object(i.b)("h3",{id:"createinitialize"},"Create/Initialize\xa0"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Creating a SharedMap")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"/**\n  * Creates the shared state using a synchronizer based on the given stream name.\n  *\n  * @param clientFactory - the Pravega ClientFactory to use to create the StateSynchronizer.\n  * @param streamManager - the Pravega StreamManager to use to create the Scope and the Stream used by the StateSynchronizer\n  * @param scope - the Scope to use to create the Stream used by the StateSynchronizer.\n  * @param name - the name of the Stream to be used by the StateSynchronizer.\n  */\n public SharedMap(ClientFactory clientFactory, StreamManager streamManager, String scope, String name){\n     streamManager.createScope(scope);\n\n     StreamConfiguration streamConfig = StreamConfiguration.builder().scope(scope).streamName(name)\n             .scalingPolicy(ScalingPolicy.fixed(1))\n             .build();\n\n     streamManager.createStream(scope, name, streamConfig);\n\n     this.stateSynchronizer = clientFactory.createStateSynchronizer(name,\n                                             new JavaSerializer<StateUpdate<K,V>>(),\n                                             new JavaSerializer<CreateState<K,V>>(),\n                                             SynchronizerConfig.builder().build());\n\n     stateSynchronizer.initialize(new CreateState<K,V>(new ConcurrentHashMap<K,V>()));\n }\n")),Object(i.b)("p",null,"A SharedMap object is created by defining the scope and stream (almost always\nthe case, the scope and stream probably already exist, so the steps in lines\n10-16 are usually no-ops. \xa0The StateSynchronizer object itself is constructed in\nlines 18-21 using the ClientFactory in a fashion similar to the way a Pravega\nReader or Writer would be created. \xa0Note that the UpdateT object and\nInitialUpdateT object can have separate Java serializers specified. \xa0Currently,\nthe SynchronizerConfig object is pretty dull; there are no configuration items\ncurrently available on the StateSynchronizer."),Object(i.b)("p",null,"The StateSynchronizer provides an initialize() API that takes an InitialUpdate\nobject. \xa0This is called in the SharedMap constructor to make sure the\nSharedState is properly initialized. \xa0Note, in many cases, the SharedMap object\nwill be created on a stream that already contains shared state for the\nSharedMap. \xa0Even in this case, it is ok to call initialize() because\ninitialize() won't modify the shared state in the Stream."),Object(i.b)("h3",{id:"read-operations"},"Read Operations"),Object(i.b)("p",null,"The read operations, operations that do not alter shared state, like get(key)\n\xa0containsValue(value) etc., work against the local copy of the\nStateSynchronizer. \xa0All of these operations retrieve the current local state\nusing getState() and then do the read operation from that state. \xa0The local\nstate of the StateSynchronizer might be stale. \xa0In these cases, the SharedMap\nclient would use refresh() to force the StateSynchronizer to refresh its state\nfrom shared state using the fetchUpdates() operation on the StateSynchronizer\nobject."),Object(i.b)("p",null,"Note, this is a design decision to trade off staleness for responsiveness. \xa0We\ncould easily have implemented the read operations to instead always do a refresh\nbefore doing the read against local state. \xa0That would be a very efficient\nstrategy if the developer expected that there will be frequent updates to the\nshared state. \xa0In our case, we had imagined that the SharedMap would be read\nfrequently but updated relatively infrequently, and therefore chose to read\nagainst local state."),Object(i.b)("h3",{id:"write-update-operations"},"Write (update) Operations"),Object(i.b)("p",null,"Each write operation is implemented in terms of the various concrete StateUpdate\nobjects we discussed earlier. \xa0The clear() operation uses the Clear subclass of\nStateUpdate to remove all the key/value pairs, put() uses the Put class, etc."),Object(i.b)("p",null,"Lets dive into the implementation of the put() operation to discuss\nStateSynchronizer programming in a bit more detail:"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Implementing put(key,value)")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-java"},"/**\n * Associates the specified value with the specified key in this map.\n *\n * @param key - the key at which the value should be found.\n * @param value - the value to be entered into the map.\n * @return - the previous value (if it existed) for the given key or null if the key did not exist before this operation.\n */\npublic V put(K key, V value){\n    final AtomicReference<V> oldValue = new AtomicReference<V>(null);\n     stateSynchronizer.updateState((state, updates) -> {\n        oldValue.set(state.get(key));\n        updates.add(new Put<K,V>(key,value));\n    });\n    return oldValue.get();\n}\n")),Object(i.b)("p",null,"It is important to note that the function provided to the StateSynchronizer's\nupdateState() will be called potentially multiple times. The result of applying the function to the old state is written\nonly when it is applied against the most current revision of the state.\nIf there was a race and the optimistic concurrency check fails, it will be called again.\nMost of the time there will only be a small number of invocations. \xa0In some cases, the\ndeveloper may choose to use fetchUpdates() to synchronize the StateSynchronizer\nwith the latest copy of shared state from the stream before running\nupdateState(). \xa0This is a matter of optimizing the tradeoff between how frequent\nupdates are expected and how efficient you want the update to be. \xa0If you expect\na lot of updates, call fetchUpdates() before calling updateState(). \xa0In our\ncase, we didn't expect a lot of updates and therefore we process potentially\nseveral invocations of the function each time put() is called."),Object(i.b)("h3",{id:"delete-operations"},"Delete Operations"),Object(i.b)("p",null,"We chose to implement the delete (remove) operations to also leverage the\ncompact() feature of StateSynchronizer. \xa0We have a policy that after every 5\nremove operations, and after every clear() operation, we do a compact operation.\n\xa0Now, we could have chosen to do a compact() operation after every 5 update\noperations, but we wanted to isolate the illustration of using compact() to just\ndelete operations."),Object(i.b)("p",null,'You can think of compact() as a form of "garbage collection" in\nStateSynchronizer. \xa0After a certain number of changes have been written to\nSharedState, it might be efficient to write out a new initial state, an\naccumulated representation of all the changes, to the Stream. \xa0That way data\nolder than the compact operation can be ignored and eventually removed from the\nStream.'),Object(i.b)("p",null,Object(i.b)("img",{alt:"state synchronizer compact",src:a(248).default})),Object(i.b)("p",null,"As a result of the compact() operation, a new initial sate (Initial2) is written\nto the stream. \xa0Now, all the data from Change3 and older is no longer relevant\nand can be garbage collected out of the Stream."))}p.isMDXComponent=!0},169:function(e,t,a){"use strict";a.d(t,"a",(function(){return h})),a.d(t,"b",(function(){return b}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=p(a),u=n,b=h["".concat(o,".").concat(u)]||h[u]||d[u]||i;return a?r.a.createElement(b,s(s({ref:t},c),{},{components:a})):r.a.createElement(b,s({ref:t},c))}));function b(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"},183:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/state.synchronizer-19251aa5a0a3fa4cfcc13fd91de8ccb9.png"},247:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/state.sync.example-9cbe4d85fe30e0997f333dc01d84cf10.png"},248:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/ss.compact-87012c2cb2a5df4fbf0f7be3ce1bfb81.png"}}]);