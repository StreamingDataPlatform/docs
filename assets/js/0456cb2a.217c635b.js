(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{160:function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return u}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),d=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=d(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),l=d(n),m=a,u=l["".concat(i,".").concat(m)]||l[m]||h[m]||o;return n?r.a.createElement(u,s(s({ref:t},p),{},{components:n})):r.a.createElement(u,s({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},72:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(3),r=n(7),o=(n(0),n(160)),i={title:"State Synchronizer Design"},s={unversionedId:"pravega/state-synchronizer-design",id:"pravega/state-synchronizer-design",isDocsHomePage:!1,title:"State Synchronizer Design",description:"\x3c!--",source:"@site/docs/pravega/state-synchronizer-design.md",slug:"/pravega/state-synchronizer-design",permalink:"/docs/docs/pravega/state-synchronizer-design",editUrl:"https://github.com/claudiofahey/pravega/edit/docusaurus/documentation/src/docs/state-synchronizer-design.md",version:"current",sidebar:"mainSidebar",previous:{title:"Pravega Streaming Service Wire Protocol",permalink:"/docs/docs/pravega/wire-protocol"},next:{title:"Reader Groups Design",permalink:"/docs/docs/pravega/reader-group-design"}},c=[{value:"Conditional Append",id:"conditional-append",children:[]},{value:"Truncate Segment",id:"truncate-segment",children:[]}],p={toc:c};function d(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"In a State Synchronizer data can be written and read by multiple processes, and the consistency is guaranteed using optimistic checks. State Synchronizer provides the abstraction of a user defined ",Object(o.b)("inlineCode",{parentName:"p"},"Java Object")," which is kept in-sync consistently across the multiple machines. All the hosts would see the same object even as it is modified."),Object(o.b)("p",null,"The ",Object(o.b)("a",{parentName:"p",href:"https://github.com/pravega/pravega/blob/master/client/src/main/java/io/pravega/client/state/StateSynchronizer.java"},"State Synchronizer API")," can be used to perform updates to the state ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),". This can be used to implement replicated state machines, schema distribution, and leader election."),Object(o.b)("p",null,"State Synchronizer works by storing a consistent history of updates to the state ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),". The updates are stored in a Pravega Stream. Pravega ensures that every process that is performing an update on the latest version of that ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),". Thus the ",Object(o.b)("inlineCode",{parentName:"p"},"Object")," is coordinated across a fleet and everyone sees the same sequence of updates on the same ",Object(o.b)("inlineCode",{parentName:"p"},"Object"),"."),Object(o.b)("p",null,"The idea is to use a Stream to persist a sequence of changes for a shared state. And allow various applications to use the ",Object(o.b)("a",{parentName:"p",href:"http://pravega.io/docs/latest/state-synchronizer/#shared-state-and-pravega"},"Pravega Java Client Library")," to concurrently read and write the shared state in a consistent fashion."),Object(o.b)("p",null,"This works by having each process keep a copy of the data. All the updates are written through the State Synchronizer which appends them to the Pravega Stream Segment. Latest updates can be incorporated to the data by consuming from the Stream Segment. To provide consistency a conditional append is used. This ensures that the updates can only proceed if the process performing them has the most recent data. To avoid the unbounded data in the Stream Segment, a compact operation is involved which re-writes the latest data and truncates the old data."),Object(o.b)("p",null,"In Pravega Stream, a Segment is always owned by a single server. This allows it to provide atomic compare-and-set operation on the Segments. This primitive is used to build a higher level abstraction at the application layer while maintaining strong consistency."),Object(o.b)("p",null,"This model works well when most of the updates are small in comparison to the total data size being stored, as they can be written as small deltas. As with any optimistic concurrency system it would work worst when many processes contend and try to update the same information at the same time."),Object(o.b)("h1",{id:"example"},"Example"),Object(o.b)("p",null,"A concrete ",Object(o.b)("a",{parentName:"p",href:"https://github.com/pravega/pravega/blob/master/client/src/test/java/io/pravega/client/state/examples/SetSynchronizer.java"},"example")," of synchronizing the contents of a Set is provided. We also have an example that is synchronizing ",Object(o.b)("a",{parentName:"p",href:"https://github.com/pravega/pravega/blob/master/client/src/test/java/io/pravega/client/state/examples/MembershipSynchronizer.java"},"membership of a set of hosts"),"."),Object(o.b)("p",null,"Imagine you want many processes to share a Map. This can be done by creating the State Synchronizer, it will aid in coordinating the changes to the Map. Each client has its own copy of the Map in memory and can apply updates by passing a generator to the State Synchronizer. Every time an update is made, the update is recorded to the Stream Segment. Updates are successful when the Map passed into the update method is consistent with all of the updates that have been recorded to the Stream Segment. If this occurs the generator is called with the latest state to try again. Thus the order of updates is defined by the order in which they are written to the Stream Segment."),Object(o.b)("h1",{id:"implementation"},"Implementation"),Object(o.b)("p",null,"For the implementation, two features of the Pravega Segment Store Service are used."),Object(o.b)("h2",{id:"conditional-append"},"Conditional Append"),Object(o.b)("p",null,"The conditional append call in the Pravega Segment Store is the cornerstone for the implementation of the State Synchronizer semantics. That is, when a client updates a piece of data via State Synchronizer, a conditional append is internally used against the Segment Store. In a conditional append, the client specifies the ",Object(o.b)("inlineCode",{parentName:"p"},"Offset")," in which the append is expected to be located. If the ",Object(o.b)("inlineCode",{parentName:"p"},"Offset")," provided by the client does match the actual ",Object(o.b)("inlineCode",{parentName:"p"},"Offset")," of the append in the Stream Segment, the operation is aborted and an error is returned to the client. This mechanism is used in the State Synchronizer to provide optimistic locks on data updates."),Object(o.b)("h2",{id:"truncate-segment"},"Truncate Segment"),Object(o.b)("p",null,"Truncate Segment deletes all data before a given ",Object(o.b)("inlineCode",{parentName:"p"},"Offset"),". This operation does not affect the existing ",Object(o.b)("inlineCode",{parentName:"p"},"Offset"),"s. Any reads for the ",Object(o.b)("inlineCode",{parentName:"p"},"Offset"),"s lower than this value will fail. Any data stored below this ",Object(o.b)("inlineCode",{parentName:"p"},"Offset")," can be removed. Truncation is performed following compaction, so that the Segment does not need to hold onto old data."))}d.isMDXComponent=!0}}]);