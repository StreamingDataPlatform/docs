<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.72">
<link rel="alternate" type="application/rss+xml" href="/docs/blog/rss.xml" title="Dell EMC Streaming Data Platform Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/docs/blog/atom.xml" title="Dell EMC Streaming Data Platform Blog Atom Feed"><title data-react-helmet="true">Pravega Concepts | Dell EMC Streaming Data Platform</title><meta data-react-helmet="true" property="og:url" content="https://StreamingDataPlatform.github.io//docs/docs/pravega/pravega-concepts"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Pravega Concepts | Dell EMC Streaming Data Platform"><meta data-react-helmet="true" name="description" content="&lt;!--"><meta data-react-helmet="true" property="og:description" content="&lt;!--"><link data-react-helmet="true" rel="shortcut icon" href="/docs/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://StreamingDataPlatform.github.io//docs/docs/pravega/pravega-concepts"><link data-react-helmet="true" rel="alternate" href="https://StreamingDataPlatform.github.io//docs/docs/pravega/pravega-concepts" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://StreamingDataPlatform.github.io//docs/docs/pravega/pravega-concepts" hreflang="x-default"><link rel="stylesheet" href="/docs/assets/css/styles.a6478483.css">
<link rel="preload" href="/docs/assets/js/styles.f634c1aa.js" as="script">
<link rel="preload" href="/docs/assets/js/runtime~main.989135b5.js" as="script">
<link rel="preload" href="/docs/assets/js/main.c08dfd08.js" as="script">
<link rel="preload" href="/docs/assets/js/1.174efca1.js" as="script">
<link rel="preload" href="/docs/assets/js/2.5b651ccc.js" as="script">
<link rel="preload" href="/docs/assets/js/97.9490d826.js" as="script">
<link rel="preload" href="/docs/assets/js/98.ea2e5b16.js" as="script">
<link rel="preload" href="/docs/assets/js/935f2afb.335ada45.js" as="script">
<link rel="preload" href="/docs/assets/js/17896441.8f7c16d3.js" as="script">
<link rel="preload" href="/docs/assets/js/26f42c5d.dc3ff4c3.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a href="https://www.dell.com/" target="_blank" rel="noopener noreferrer" class="navbar__brand"><img src="/docs/img/logo.svg" alt="Dell Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs/img/logo.svg" alt="Dell Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/docs/sdp/overview">Docs</a><a class="navbar__item navbar__link" href="/docs/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/pravega/pravega" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_GrZ2"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a href="https://www.dell.com/" target="_blank" rel="noopener noreferrer" class="navbar__brand"><img src="/docs/img/logo.svg" alt="Dell Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/docs/img/logo.svg" alt="Dell Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/docs/sdp/overview">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/pravega/pravega" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper main-docs-wrapper"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Streaming Data Platform</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/about">About</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Installation and Administration</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/install/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/install/guide">Guide</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Troubleshooting</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/troubleshooting/overview">Overview</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Developer&#x27;s Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/developer-guide/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/developer-guide/guide">Guide</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Analytics</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Flink</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/analytics/flink/overview">Overview</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Spark</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/analytics/spark/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/analytics/spark/deploying">Deploying</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/analytics/spark/troubleshooting">Troubleshooting</a></li></ul></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Security Configuration Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/security-configuration/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/security-configuration/guide">Guide</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">SDP on Edge</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/edge/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/edge/solution-architecture">Solution Architecture</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/edge/pravega-sensor-collector">Pravega Sensor Collector</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/sdp/edge/pravega-flink-tools">Pravega Flink Tools</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Pravega</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/overview">Pravega Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/getting-started">Getting Started</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Understanding Pravega</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/docs/pravega/pravega-concepts">Pravega Concepts</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/terminology">Terminology</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/key-features">Pravega Key Features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/faq">Frequently Asked Questions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/segment-store-service">Pravega Segment Store Service</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/segment-containers">Segment Containers in a Pravega Cluster</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/controller-service">Pravega Controller Service</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/wire-protocol">Pravega Streaming Service Wire Protocol</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/state-synchronizer-design">State Synchronizer Design</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/reader-group-design">Reader Groups Design</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docs/pravega/watermarking">Watermarking</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Developing Pravega Applications</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/pravega-write-read-methods">Methods for Writing and Reading Pravega Streams</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/javadoc">Java API Reference</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/rest/restapis">Pravega Controller APIs</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/connectors">Pravega Connectors</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/basic-reader-and-writer">Basic Reader and Writer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/state-synchronizer">State Synchronizer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/transactions">Transactions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/streamcuts">StreamCuts</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Running Pravega</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/deployment/deployment">Pravega Deployment Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/deployment/manual-install">Manual Installation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/deployment/kubernetes-install">Deploying in Kubernetes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/deployment/docker-swarm">Deploying in a Docker Swarm</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/deployment/dcos-install">Deploying on DC/OS</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/deployment/aws-install">Running on AWS</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/metrics">Pravega Metrics</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Pravega Security</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/auth/auth-plugin">Implementation of Pravega Authentication/Authorization Plugin</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/auth/client-auth">Client Auth Interface</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/security/pravega-security-authorization-authentication">TLS, Authorization, Authentication - Enabling encryption, authorization and authentication features</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/security/pravega-security-configurations">Pravega Security Configurations</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/security/pravega-security-encryption">Pravega Encryption</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/security/securing-standalone-mode-cluster">Setting Up Security for a Standalone Mode Server</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/security/securing-distributed-mode-cluster">Setting Up Security for a Distributed Mode Cluster</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Contributing to Pravega</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/contributing">Contributing to Pravega</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/roadmap">Pravega Roadmap</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/pravega/join-community">Join the Pravega Community</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Connectors</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Flink</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/flink-connectors/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/flink-connectors/getting-started">Getting Started</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/flink-connectors/quickstart">Quick Start</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/flink-connectors/dev-guide">Developer&#x27;s Guide</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Features</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/flink-connectors/streaming">Streaming</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/flink-connectors/batch">Batch</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/flink-connectors/table-api">Table API</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/flink-connectors/metrics">Metrics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/flink-connectors/configurations">Configurations</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/flink-connectors/serialization">Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Spark</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/spark-connectors/overview">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/spark-connectors/getting-started">Getting Started</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/spark-connectors/prepare-development-environment">Prepare Development Environment</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Tutorials</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/spark-connectors/tutorial-1-writing-to-pravega">Tutorial 1 - Writing to Pravega</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/spark-connectors/tutorial-2-reading-from-pravega">Tutorial 2 - Reading from Pravega</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/spark-connectors/samples">Samples</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/spark-connectors/configuration">Configuration</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/spark-connectors/build-connector">Building the Connector</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/spark-connectors/limitations">Limitations</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/docs/spark-connectors/learn-more">Learn More</a></li></ul></li><li class="menu__list-item"><a href="https://github.com/pravega/nifi-pravega" target="_blank" rel="noopener noreferrer" class="menu__link menuLinkExternal_1OhN" tabindex="-1">NiFi</a></li><li class="menu__list-item"><a href="https://github.com/pravega?q=logstash" target="_blank" rel="noopener noreferrer" class="menu__link menuLinkExternal_1OhN" tabindex="-1">Logstash</a></li><li class="menu__list-item"><a href="https://github.com/pravega/boomi-connector" target="_blank" rel="noopener noreferrer" class="menu__link menuLinkExternal_1OhN" tabindex="-1">Boomi</a></li><li class="menu__list-item"><a href="https://github.com/pravega/kafka-adapter" target="_blank" rel="noopener noreferrer" class="menu__link menuLinkExternal_1OhN" tabindex="-1">Kafka Adapter</a></li></ul></li></ul></div><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" role="img" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">Pravega Concepts</h1></header><div class="markdown"><ul><li><a href="#introduction">Introduction</a></li><li><a href="#streams">Streams</a></li><li><a href="#events">Events</a></li><li><a href="#writers-readers-reader-groups">Writers Readers Reader Groups</a></li><li><a href="#stream-segments">Stream Segments</a><ul><li><a href="#events-in-a-stream-segment">Events in a Stream Segment</a></li><li><a href="#stream-segments-and-connection-pooling">Stream Segments and Connection Pooling</a></li><li><a href="#elastic-streams-auto-scaling">Elastic Streams Auto Scaling</a></li><li><a href="#events-stream-segments-and-auto-scaling">Events Stream Segments and Auto scaling</a></li><li><a href="#stream-segments-and-reader-groups">Stream Segments and Reader Groups</a></li><li><a href="#ordering-guarantees">Ordering Guarantees</a></li><li><a href="#reader-group-checkpoints">Reader Group Checkpoints</a></li></ul></li><li><a href="#transactions">Transactions</a></li><li><a href="#state-synchronizers">State Synchronizers</a></li><li><a href="#architecture">Architecture</a></li><li><a href="#putting-the-concepts-together">Putting the Concepts Together</a></li><li><a href="#a-note-on-tiered-storage">A Note on Tiered Storage</a><ul><li><a href="#stream-retention-policies">Stream Retention Policies</a></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="introduction"></a>Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">#</a></h2><p>Pravega is an open source storage system implementing <strong>Streams</strong> as first-class primitive for storing/serving continuous and unbounded data.</p><p>Next, we overview the key concepts in Pravega. For a concise definition of key terms of Pravega concepts, pleaseÂ seeÂ <a href="/docs/docs/pravega/terminology">Terminology</a>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="streams"></a>Streams<a class="hash-link" href="#streams" title="Direct link to heading">#</a></h2><p>Pravega organizes data into Streams.Â A Stream is a durable, elastic, append-only, unbounded sequence of bytes having good performance and strong consistency. Â A Pravega Stream is
similar to but more flexible than a &quot;topic&quot; in popular message oriented middleware such as <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener noreferrer">RabbitMQ</a> or <a href="https://kafka.apache.org/" target="_blank" rel="noopener noreferrer">Apache Kafka</a>.</p><p>Pravega Streams are based on an append-only log data structure. By using append-only logs, Pravega rapidly ingests data into durable storage. It supports a large variety of application use cases:</p><ul><li>Stream processing with frameworks like <a href="https://flink.apache.org" target="_blank" rel="noopener noreferrer">Flink</a>.</li><li>Publish/subscribe messaging.</li><li>NoSQL databases like Time Series Database (TSDB).</li><li>Workflow engines.</li><li>Event-oriented applications, etc.Â </li></ul><p>When a developer creates a Stream in Pravega, s/he gives the Stream a meaningful name such as &quot;IoTSensorData&quot; or &quot;WebApplicationLog20170330&quot; to inform about the type of data it stores. Moreover, Pravega Stream names are organized within Scopes. A Scope acts as a namespace for Stream names; all Stream names are unique within their Scope. Therefore, a Stream is uniquely identified by the combination of its name and Scope. Developers can also define meaningful Scope names, such as &quot;FactoryMachines&quot; or &quot;HRWebsitelogs&quot;, to effectively organize collections of Streams. For example, Scopes can be used to classify Streams by tenant (in a multi tenant environment), by department in an organization or by geographic location.</p><p>A Stream is unbounded in size â€“ Pravega itself does not impose any limits on how many <a href="#events"><strong>Events</strong></a> (i.e., bytes) are stored in a Stream. Pravegaâ€™s design horizontally scales from few machines to a whole datacenterâ€™s capacity.</p><p>Pravega Streams are divided into <strong>Stream Segments</strong> to handle a large volume of data within a Stream. A Stream Segment is a shard, or partition of the data within a Stream. For more information, please see <a href="#stream-segments">Stream Segments</a> section.</p><p>Applications, such as a Java program reading from an IoT sensor, write data to the tail (front) of the Stream. Analytics applications, such as a <a href="https://flink.apache.org" target="_blank" rel="noopener noreferrer">Flink</a> or <a href="https://hadoop.apache.org/" target="_blank" rel="noopener noreferrer">Hadoop</a> jobs, can read from any point in the Stream. Many applications can read and write the same Stream in parallel.Â Elasticity, scalability, support for large volume of Stream data and applications are the highlights of Pravega&#x27;s design. More information on read and write operations in the Streams will be discussed in the <a href="#writers-readers-reader-groups">Readers and Writers</a> section.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="events"></a>Events<a class="hash-link" href="#events" title="Direct link to heading">#</a></h2><p>Pravega&#x27;s client API allows applications to write and read data to/from Pravega in the form of <strong>Events</strong>. An Event is represented as a set of bytes within a Stream.Â For example, an Event could be as simple as a small number of bytes containing a temperature reading from an IoT sensor composed of
a timestamp, a metric identifier and a value. An Event could also be a web log data
associated with a user click on a website.Â Applications make sense of Events using
standard Java <strong>serializers</strong> and <strong>deserializers</strong>, allowing them to read and write
objects in Pravega similarly to reading and writing objects from
files.</p><p>Every Event has a <strong>Routing Key</strong>. A Routing Key isÂ a string used by developers to group similar Events.Â A Routing Key is often derived from data naturally occurring in the Event,
like &quot;customer-id&quot; or &quot;machine-id&quot; or a declared/user-defined string. For example, a Routing Key could be aÂ date (to group Events together by time) or it could be a IoT sensor id (to group Events by
machine). A Routing Key is important in defining the read and write semantics that Pravega guarantees.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="writers-readers-reader-groups"></a>Writers, Readers, Reader Groups<a class="hash-link" href="#writers-readers-reader-groups" title="Direct link to heading">#</a></h2><p><img alt="Reader Client" src="/docs/assets/images/producer.consumer.client.new-11f02baa6168ab16110157306eff3535.png"></p><p>Pravega provides a client library, written in Java, that implements a convenient
API for Writer and Reader applications.Â  The Pravega Java Client Library
encapsulates the Wire Protocol used to communicate Pravega clients and
servers.</p><ul><li><p><strong>Writer:</strong> An application that creates Events and writes them into a Stream.
All data is written by appending to the tail (front) of a Stream.</p></li><li><p><strong>Reader:</strong> An application that reads Events from a Stream. Â Readers can read
from any point in the Stream.Â  Many Readers will be reading Events from the tail
of the Stream.Â Tail reads corresponding to recently written Events are immediately delivered to Readers.
Some Readers will read from earlier parts of the Stream (called <strong>catch-up reads</strong>). The application developer has control over the Reader&#x27;s start position in the Stream.</p></li><li><p><strong>Position:</strong> Abstraction that represents where in a Stream a Reader is currently located. The Position object can be used as a recovery
mechanismÂ by replacing the failed Reader by a new Reader starting at the last saved successful read Position.Â Using this pattern of persisting position objects, applications can be built guaranteeing exactly-once Event processing in the presence of Reader failures.</p></li><li><p><strong>Reader Groups:</strong> Readers are organized into Reader Groups.Â A Reader Group is a named collection of
Readers, which together perform parallel reads from a given Stream.Â When a
Reader is created through the Pravega data plane API, the developer includes the
name of the Reader Group associated with it.Â Pravega guarantees that each Event published
to a Stream is sent to exactly one Reader within the Reader Group. There could
be one or more Readers in the Reader Group and there could be many different Reader Groups simultaneously reading from any given Stream. A Reader Group can be considered as a &quot;composite Reader&quot; or &quot;distributed Reader&quot;, that allows a distributed application to read and process Stream data
in parallel. A large amount of Stream data can be consumed by a coordinated group of Readers in a Reader Group. Â For example, a collection of Flink tasks processing Stream data in parallel using Reader Group.</p></li></ul><p>For more details on the basics of working with Pravega Readers and Writers, please see <a href="/docs/docs/pravega/basic-reader-and-writer#working-with-pravega-basic-reader-and-writer">Working with Pravega: Basic Reader and
Writer</a>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="stream-segments"></a>Stream Segments<a class="hash-link" href="#stream-segments" title="Direct link to heading">#</a></h2><p>A Stream is split into a set of shards or partitions generally referred as <strong>Stream Segments</strong>.</p><p><img alt="Stream Segment" src="/docs/assets/images/stream.segment-1579f009dd616e766877367684f7c5ea.png">Â </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="events-in-a-stream-segment"></a>Events in a Stream Segment<a class="hash-link" href="#events-in-a-stream-segment" title="Direct link to heading">#</a></h3><p>The Stream Segments acts as a container for Events within the Stream. When an
Event is written into a Stream, it is stored in one of the Stream Segments based
on the Event&#x27;s Routing Key. Pravega uses consistent hashing to assign Events to
Stream Segments.Â Event Routing Keys are hashed to form a &quot;key space&quot;. The key
space is then divided into a number of partitions, corresponding to the number
of Stream Segments. Consistent hashing determines of Events to Stream Segments.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="stream-segments-and-connection-pooling"></a>Stream Segments and Connection pooling<a class="hash-link" href="#stream-segments-and-connection-pooling" title="Direct link to heading">#</a></h3><p>Event is written to one of the Stream Segments by the Pravega Client based on the Event Routing Key in the Stream. The Stream Segments are managed by the different <a href="/docs/docs/pravega/segment-store-service">Segment Store</a> Service instances in the Stream. A new connection to a Segment Store is created even when multiple Segments are owned by the same Segment Store. Every Segment being read by the Pravega client maps to a new connection.
The number of connections created increases if the user is writing and reading from multiple Streams.
The goal of <strong>connection pooling</strong> is to ensure a common pool of connections between the client process and the Segment Stores, which does not require a linear growth of the number of connections with the number of Segments.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="elastic-streams-auto-scaling"></a>Elastic Streams: Auto Scaling<a class="hash-link" href="#elastic-streams-auto-scaling" title="Direct link to heading">#</a></h3><p>A unique feature of Pravega is that the number of parallel Stream Segments in a Stream can automatically <strong>grow</strong> and <strong>shrink</strong> over time based on the I/O load it receives. This feature is known as <strong>Auto Scaling</strong>.</p><p>Consider the following figure that shows the relationship between Routing Keys
and time.</p><p><img alt="Stream Segment" src="/docs/assets/images/segment.split.merge.overtime.new-88dcad51602de0a4473b66979a7e0747.png">Â </p><ul><li><p>A Stream starts at time <strong>t0</strong> with a configurable number of Stream Segments.Â  If the
rate of data written to the Stream is constant, there will be no change in the number of Stream Segments.Â </p></li><li><p>At time <strong>t1</strong>, the system noted an increase in the ingestion rate and splits Stream <strong>Segment 1</strong> into two parts. This process is referred as <strong>Scale-Up</strong> Event.</p></li><li><p>Before <strong>t1</strong>, Events with a Routing Key that hashes to the upper part of the key
space (i.e., values ranging from <strong>200-399</strong>) would be placed in Stream <strong>Segment 1</strong> and those that hash into the
lower part of the key space (i.e., values ranging from <strong>0-199</strong>) would be placed in Stream <strong>Segment 0</strong>.</p></li><li><p>After <strong>t1</strong>, Stream <strong>Segment 1</strong> is split into Stream <strong>Segment 2</strong> and Stream <strong>Segment 3</strong>. The Stream <strong>Segment 1</strong> is sealed and stops accepting writes. Â At this point in time, Events with Routing Key <strong>300</strong>Â andÂ <em>above</em> are written to Stream <strong>Segment 3</strong> and those between <strong>200</strong> and <strong>299</strong> would be written into Stream <strong>Segment 2</strong>.</p></li><li><p>Stream <strong>Segment 0</strong> continues acceptingÂ theÂ same range of Events as before <strong>t1</strong>. Â </p></li><li><p>Another scale-up Event occurs at time <strong>t2</strong>, as Stream <strong>Segment 0</strong>â€™s range of Routing
Key is split into Stream <strong>Segment 5</strong> and Stream <strong>Segment 4</strong>. Also at this time, Stream <strong>Segment 0</strong> is sealed
and allows no further writes.</p></li><li><p>Stream Segments covering a contiguous range of the key space can also be merged.Â At
time <strong>t3</strong>, Stream <strong>Segment 2</strong>â€™s range and Stream <strong>Segment 5</strong>â€™s range are merged to Stream <strong>Segment 6</strong> to
accommodate a decrease in the load on the Stream.</p></li></ul><p>When a Stream is created, it is configured with a <strong>Scaling Policy</strong> that
determines how a Stream handles the varying changes in its load. Pravega has three kinds of Scaling Policy:</p><ol><li><p><strong>Fixed</strong>: Â The number of Stream Segments does not vary with load.</p></li><li><p><strong>Data-based</strong>: Pravega splits a Stream Segment into multiple ones (i.e., Scale-up Event) if the number of bytes per second written to that Stream Segment increases beyond a defined threshold. Similarly, Pravega merges two adjacent Stream Segments (i.e., Scale-down Event) if the number of bytes written to them fall below a defined threshold. Note that, even if the load for a Stream Segment reaches the defined threshold, Pravega does not immediately trigger a Scale-up/down Event. Instead, the load should be satisfying the scaling policy threshold for a <a href="https://github.com/pravega/pravega/blob/master/client/src/main/java/io/pravega/client/stream/ScalingPolicy.java" target="_blank" rel="noopener noreferrer">sufficient amount of time</a>.</p></li><li><p><strong>Event-based</strong>:Â Similar to the data-based scaling policy, but it uses number of Events instead of bytes.</p></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="events-stream-segments-and-auto-scaling"></a>Events, Stream Segments and Auto Scaling<a class="hash-link" href="#events-stream-segments-and-auto-scaling" title="Direct link to heading">#</a></h3><p>As mentioned earlier in this section, that an Event is written into one of the Stream Segments. By considering Auto Scaling, Stream Segments performs bucketing of Events based on Routing Key and time.Â It is obvious that, at any given time, Events published to a Stream with a given value of Routing Key will appear in the same Stream Segment.</p><p><img alt="Stream Segment" src="/docs/assets/images/rk.segment.new-d4bbd87de8f2b3938d93d4b020a5ce3f.png">Â </p><p>It is also worth emphasizing that Events are written only on the active Stream
Segments.Â Stream Segments that are sealed do not accept writes.Â In the figure above,
at time <strong>now</strong>, only Stream <strong>Segments 3</strong>, <strong>6</strong> and <strong>4</strong> are active and the entire key space is covered between those three Stream Segments. Â </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="stream-segments-and-reader-groups"></a>Stream Segments and Reader Groups<a class="hash-link" href="#stream-segments-and-reader-groups" title="Direct link to heading">#</a></h3><p>Stream Segments play a major role in understanding the way Reader Groups work.</p><p><img alt="Stream Segment" src="/docs/assets/images/segment.readergroup-2977811de2d104670a4e3a6a9d8c5018.png">Â </p><p>Pravega assigns <em>zero</em> <em>or</em> <em>more</em> Stream Segments to each Reader in a Reader Group. Pravega tries to balances the number of Stream Segments assigned to each Reader. In the figure above, <strong>Reader B1</strong> reads from two Stream Segments (<strong>Segment 0</strong> and <strong>Segment 3</strong>), while the other Reader Group (<strong>Reader B2</strong>, <strong>Reader B3</strong>) have only only one Stream Segment to read from.Â Pravega makes sure that each Stream Segment is read exactly by one Reader in any Reader Group configured with that Stream. Irrespective of  Readers being added to the Reader Group or removed from the Reader Group due to crash, Pravega reassigns Stream Segments to maintain balance among the Readers.</p><p>The number of Stream Segments in a Stream determines the upper bound of
parallelism of readers within a Reader Group. If there are more Stream Segments, different Reader Groups and many parallel sets of Readers can effectively consume the Stream.Â In the above figure, <strong>Stream 1</strong> has four Stream Segments. The largest effective Reader Group would contain four Readers. <strong>Reader Group B</strong> in the above figure is not quite optimal. If one more Reader was added to the Reader Group, each Reader would have one Stream Segment to process, thus maximizing read
parallelism. However, the number of Readers in the Reader Group increases beyond
4, at least one of the Readers will not be assigned a Stream Segment.</p><p>If <strong>Stream 1</strong> in the figure above experienced a <strong>Scale-Down</strong> event, by reducing the
number of Stream Segments to three, then the <strong>Reader Group B</strong>  will have an
ideal number of Readers.</p><p>The number of Stream Segments change over time by using the Pravega&#x27;s Auto Scaling feature as we discussed in the <a href="#elastic-streams-auto-scaling">Auto Scaling</a> section. The size of any Stream is determined by the storage capacity of the Pravega cluster. More Streams can be obtained by increasing the storage of the Pravega cluster.</p><p>Applications can react to changes in the number of Stream Segments in a Stream by adjusting the number of Readers within a Reader Group to maintain optimal read parallelism.Â As a cool use case, Pravega may allow Flink to increase or decrease the number of task instances that are processing a Stream in parallel.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ordering-guarantees"></a>Ordering Guarantees<a class="hash-link" href="#ordering-guarantees" title="Direct link to heading">#</a></h3><p>A Stream comprises a set of Segments that can change over time. Segments that overlap in their area of key space have a defined order.</p><p>An Event written to a Stream is written to a single Stream Segment, and is ordered with respect to the Events of that Stream Segment. The existence and position of an Event within a Stream Segment is strongly consistent.</p><p>Readers can be assigned multiple parallel Stream Segments (from different parts of key space). A Reader reading from multiple Stream Segments will interleave the Events of the Stream Segments, but the order of Events per Stream Segment is retained. Specifically, if <strong>s</strong> is a Stream Segment, and <strong>s</strong> contains two Events <em>i.e.,</em> <strong>s</strong> <strong>=</strong> {<strong>e~1</strong>,<strong>e~2</strong>} where <strong>e~1</strong> precedes <strong>e~2</strong>. Thus, for a Reader reading Stream Segments, it is guaranteed that <strong>e~1</strong> will be read before <strong>e~2</strong>.</p><p>This results in the following ordering guarantees:</p><ul><li><p>Events with the same Routing Key are consumed in the order they were written.</p></li><li><p>Events with different Routing Keys are sent to a specific Stream Segment and will always be
read in the same order even if the Reader performs back ups and re-reads.</p></li><li><p>If an Event has been acknowledged to its Writer or has been read by a Reader, it is guaranteed that  it will continue to exist in the same location or position for all subsequent reads until it is deleted.</p></li><li><p>If there are multiple Readers reading a Stream and they all back up to any given point, they will never see any reordering with respect to that point. (It will never be the case that an event that they read before the chosen point now comes after or vice versa).</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="reader-group-checkpoints"></a>Reader Group Checkpoints<a class="hash-link" href="#reader-group-checkpoints" title="Direct link to heading">#</a></h2><p>Pravega provides the ability for an application to initiate a <strong>Checkpoint</strong> on a
Reader Group. Â The idea with a Checkpoint is to create a consistent &quot;point in
time&quot; persistence of the state of each Reader in the Reader Group, by using a
specialized Event (<em>Checkpoint Event</em>) to signal each Reader to preserve its
state. Once a Checkpoint has been completed, the application can use the
Checkpoint to reset all the Readers in the Reader Group to the known consistent
state represented by the Checkpoint.</p><p>For more details on working with Reader Groups, Please seeÂ <a href="/docs/docs/pravega/basic-reader-and-writer#readergroup-basics">Reader Group Basics</a>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="transactions"></a>Transactions<a class="hash-link" href="#transactions" title="Direct link to heading">#</a></h2><p>Pravega supports Transactions. The idea of a Transaction is that a Writer can
&quot;batch&quot; up a bunch of Events and commit them as a unit into a Stream. This is
useful, for example, in Flink jobs, using Pravega as a sink.Â The Flink job
can continuously produce results for some data processing and use the Transaction
to durably accumulate the results of the processing.Â For example, at the end of some sort of
time window, the Flink job can commit the Transaction and therefore
make the results of the processing available for downstream processing, or in
the case of an error, the Transaction is aborted and the results disappear.</p><p>A key difference between Pravega&#x27;s Transactions and similar approaches (Kafka&#x27;s producer-side batching) vary with the feature durability. Events added to a Transaction are durable when the Event is acknowledged back to the Writer.Â However, the Events in the Transaction are <em>not</em> visible to Readers until the Transaction is committed by the Writer.Â A Transaction is a similar to a Stream and is  associated with multiple Stream Segments. Â When an Event is published into a
Transaction, the Event itself is appended to a Stream Segment of the
Transaction.Â </p><p>For example, a Stream has five Stream Segments, when a Transaction is created on that
Stream, conceptually that Transaction also has five Stream Segments.Â When an Event is
published into the Transaction, it is routed and assigned to the same numbered Stream Segment similar to Stream (i.e., Event assigned to Stream <strong>Segment 3</strong> in the Stream will be assigned to <strong>Segment 3</strong> in the Transaction).Â Once the Transaction is committed, all the Transaction Segments are automatically appended to their corresponding Stream Segment in the Stream. If the Transaction is aborted, the Transaction, all its Stream Segments and all the Events published into the Transaction are removed from Pravega.</p><p><img alt="Transaction" src="/docs/assets/images/trx.commit.new-b51cfaf09244e52245123275c5f3cedd.png">Â </p><p>Events published into a Transaction are visible to the Reader only after the Transaction is committed.</p><p>For more details on working with Transactions, please seeÂ <a href="/docs/docs/pravega/transactions">Working with Pravega:
Transactions</a>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="state-synchronizers"></a>State Synchronizers<a class="hash-link" href="#state-synchronizers" title="Direct link to heading">#</a></h2><p>Pravega implements various building blocks to materialize the Stream primitive. One of such building blocks, namely <strong>State Synchronizer</strong>, is aimed at coordinating processes in a distributed computing environment. Internally, the <strong>State Synchronizer</strong> uses a Pravega Stream to provide a synchronization
mechanism for state shared between multiple processes running in a cluster and making it easier to build distributed applications. With State Synchronizer, an application developer can use Pravega to read and make changes to shared state consistently and perform optimistic locking.Â </p><p><img alt="State synchroner" src="/docs/assets/images/state.synchronizer-19251aa5a0a3fa4cfcc13fd91de8ccb9.png">Â </p><p>State Synchronizer could be used to maintain a single, shared copy of an
application&#x27;s configuration property across all instances of thatÂ applicationÂ in
a cloud. Â State Synchronizer could also be used to store one piece of data or a
map with thousands of different key value pairs. In Pravega, managing the state of Reader Groups and distribution of Readers throughout the network is implemented using State Synchronizer.</p><p>An application developer creates a State Synchronizer on a Stream similar to the creation of a Writer. The State Synchronizer keeps a local copy of the shared state and allows faster access to the data for the application. State Synchronizer keeps trackÂ of all the changes happening in the shared state and it is responsible for performing any modification to the shared state in the Stream.Â EachÂ applicationÂ instance uses the State Synchronizer, to remain updated with the
changes by pulling updates to the shared state and modifying the local copy of the
data. Consistency is maintained through a conditional append style of updates
to the shared state through the State Synchronizer, making sure that updates are
made only to the most recent version of the shared state.</p><p>The State Synchronizer can occasionally be &quot;compacted&quot; by compressing and removing older updates, while retaining only the most recent version of the state in the backing Stream. This feature assures the application developers, that the shared state does not grow unchecked.</p><p>State Synchronizer works effectively when most updates to shared state are small in
comparison to the total data size being stored. This can be achieved by allowing them to be written as
small deltas. As with any optimistic concurrency system, State Synchronizer is
not at its best when many processes attempt for simultaneous updates on the same piece of data.</p><p>For more details on working with State Synchronizers, please seeÂ <a href="/docs/docs/pravega/state-synchronizer">Working with Pravega:
State Synchronizer</a>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="architecture"></a>Architecture<a class="hash-link" href="#architecture" title="Direct link to heading">#</a></h2><p>The following figure depicts the components deployed by Pravega:</p><p><img alt="pravega high level architecture" src="/docs/assets/images/pravega.arch.new-10a7437f9303bc398bf3fb28f5585b10.png"></p><p>Pravega is deployed as a distributed system â€“ a cluster of servers and storage
coordinated to run Pravega called a <strong>Pravega cluster</strong>. Â </p><p>Pravega presents a software-defined storage (SDS) architecture formed by <strong>Controller</strong> instances
(<em>control plane</em>) and Pravega Servers (<em>data plane</em>). The set of Pravega Servers is collectively known as the <strong>Segment Store</strong>.Â </p><p>The set of Controller instances together forms the control plane of Pravega, providing
functionality to <em>create, update</em> and <em>delete</em> Streams. Further, it extends the functionality to retrieveÂ information about the Streams,Â monitor the health of the Pravega cluster, gather metrics, etc.  There
are usually multiple (recommended at least 3) Controller instances running in a running in a cluster for high availability. Â </p><p>The <a href="/docs/docs/pravega/segment-store-service">Segment Store</a> implements the Pravega data plane.
Pravega Servers provide the API to read and write data in Streams.Â Data storage is comprised of two tiers:</p><ul><li><p><strong>Tier 1:</strong>Â It provides short term, low-latency data storage,Â guaranteeing the durability of data written to Streams. Pravega usesÂ <a href="http://bookkeeper.apache.org/" target="_blank" rel="noopener noreferrer">Apache Bookkeeper</a>Â to implement
Tier 1 Storage. Tier 1 Storage typically runs <em>within</em> the Pravega cluster.</p></li><li><p><strong>Tier 2:</strong> It provides long term storage for Stream data. Pravega uses HDFS, Dell EMC&#x27;s Isilon or Dell EMC&#x27;s Elastic Cloud Storage (ECS) to implement Tier 2 Storage.  Tier 2 Storage is normally deployed <em>outside</em> the Pravega cluster.</p></li></ul><p>Storage tiering allows Pravega to achieve a sweet spot in the latency vs throughput trade-off. This makes Pravega an ideal storage substrate for serving data to both real-time and batch (analytics) applications. Moreover, as data in Tier 1 Storage ages, it is automatically moved into Tier 2 Storage. Thus, Pravega can store vasts amounts of Stream data and applications can read it at any time, while being oblivious to its actual location.</p><p>Pravega uses <a href="https://zookeeper.apache.org/" target="_blank" rel="noopener noreferrer">Apache Zookeeper</a> as the
coordination mechanism for the components in the Pravega cluster. Â </p><p>Pravega is a distributed storage system providing the Stream primitive first and foremost. Pravega is
carefully designed to take advantage of software-defined storage, so that the
amount of data stored in Pravega is limited only by the total storage capacity
of the data center. Once an Event is written to Pravega, it is durably stored and replicated so it can survive permanent crashes of datacenter nodes.</p><p>Pravega provides a <strong>Java Client Library</strong>, for building client-side
applications such as analytics applications using Flink.Â The Pravega Java Client
Library manages the interaction between the application code and Pravega via a
custom TCP Wire Protocol.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="putting-the-concepts-together"></a>Putting the Concepts Together<a class="hash-link" href="#putting-the-concepts-together" title="Direct link to heading">#</a></h2><p>The concepts in Pravega are depicted in the following figure:</p><p><img alt="State synchroner" src="/docs/assets/images/putting.all.together.new-08aced7b5f2c25605621e9e120680e39.png">Â </p><ul><li><p>Pravega clients are Writers and Readers.Â  Writers write Events into a
Stream.Â Readers read Events from a Stream. Readers are grouped into
Reader Groups to read from a Stream in parallel.</p></li><li><p>The Controller is a server-side component that manages the control plane of
Pravega.Â  Streams are created, updated and listed using the Controller API.</p></li><li><p>The Pravega Server is a server-side component that implements reads, writes
and other data plane operations.</p></li><li><p>Streams are the fundamental storage primitive in Pravega. Â Streams contain a
set of data elements called Events.Â  Events are appended to the â€œtailâ€ of
the Stream by Writers.Â  Readers can read Events from anywhere in the Stream.</p></li><li><p>A Stream isÂ partitioned into a set of Stream Segments. The number of Stream
Segments in a Stream can change over time. Â Events are written into exactly
one of the Stream Segments based on Routing Key. Â For any Reader Group reading a Stream, each Stream Segment is assigned to one Reader in that
Reader Group.Â </p></li><li><p>Each Stream Segment is stored in a combination of Tier 1 and Tier 2 Storage.Â 
The tail of the Stream Segment is stored in Tier 1 providing low latency reads and
writes. The rest of the Stream Segment is stored in Tier 2, providing high
throughput read access with horizontal scalability and low cost.Â </p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="a-note-on-tiered-storage"></a>A Note on Tiered Storage<a class="hash-link" href="#a-note-on-tiered-storage" title="Direct link to heading">#</a></h2><p>To deliver an efficient implementation of Streams, Pravega is based on a tiered
storage model.Â  Events are persisted in low latency/high IOPS storageÂ (Tier 1
Storage, write-ahead log) and higher throughput Tier 2 storage (e.g., file system, object store). Writers and Readers are oblivious to the tiered storage model from an API perspective.Â </p><p>In Pravega, Tier 1 is based on an append-only <strong>Log</strong> data structure.Â  As Leigh Stewart
<a href="https://blog.twitter.com/2015/building-distributedlog-twitter-s-high-performance-replicated-log-service" target="_blank" rel="noopener noreferrer">observed</a>,
there are really three data access mechanisms in a Log:</p><p><img alt="State synchroner" src="/docs/assets/images/anatomy.of.log-dcc0a6a0a7106819770265bfdadc4f5f.png">Â </p><p>All of the write activity, and much of the read activity happens at the tail of
the log.Â  Writes are appended to the log and many clients try to read data immediately as it is written to the log.Â These two data access mechanisms are dominated by the need for low latency â€“ low latency writes by Writers and near real-time access to the published data by Readers.</p><p>Please note that not all Readers read from the tail of the log. Some Readers read
by starting at some arbitrary position in the log.Â  These reads are known as
<strong>catch-up reads</strong>.Â  Access to historical data traditionally was done by batch
analytics jobs, often using HDFS and Map/Reduce.Â  However with new streaming
applications, we can access historical data as well as current data by just
accessing the log. Â One approach would be to store all the historical data in
SSDs similar to tail data operations, but that leads to an expensive task and force
customers to economize by deleting historical data.</p><p>Pravega offers a mechanism that allows customers to use cost-effective, highly-scalable, high-throughput
storage for the historical part of the log, that way they wonâ€™t have to decide on
when to delete historical data.Â  Basically, if storage is cheap enough, why not
keep all of the history?</p><p>Tier 1 Storage aids in faster writes to the Streams by assuring durability and makes reading from the tail of a Stream much quicker.Â Tier 1 Storage is based on the open source Apache BookKeeper Project. Though not essential, we presume that the Tier 1 Storage will be typically implemented on faster SSDs or
even non-volatile RAM.</p><p>Tier 2 Storage provides a highly-scalable, high-throughput cost-effective
storage. We expect this Tier 2 to be typically deployed on spinning disks. Pravega
asynchronously migrates Events from Tier 1 to Tier 2 to reflect the different
access patterns to Stream data. Tier 2 Storage is based on an HDFS model.Â </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="stream-retention-policies"></a>Stream Retention Policies<a class="hash-link" href="#stream-retention-policies" title="Direct link to heading">#</a></h3><p>Pravega allows users to store data in Tier 2 as long as there is storage capacity available. But sometimes, users may not be interested to keep all the historical data related to a Stream. Instead, there are use-cases in which it may be useful to retain just a fraction of a Stream&#x27;s data. For this reason, Streams can be configured with <strong>Retention Policies</strong>.  </p><p>Pravega supports two types of Retention Policies:</p><ul><li><p><strong>Time-based Retention</strong>: It allows the developer to control for how long the data is kept in a Stream before it is deleted. The developer can specify the time limit (milliseconds) in the Stream policy, which is ideal for situations like regulatory compliance that mandate certain retention periods.</p></li><li><p><strong>Size-based Retention</strong>: Retains the newest subset of a Stream&#x27;s data that does not exceed the specified size in bytes.</p></li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/claudiofahey/pravega/edit/docusaurus/documentation/src/docs/pravega-concepts.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/docs/pravega/getting-started"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Getting Started</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/docs/pravega/terminology"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Terminology Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#introduction" class="table-of-contents__link">Introduction</a></li><li><a href="#streams" class="table-of-contents__link">Streams</a></li><li><a href="#events" class="table-of-contents__link">Events</a></li><li><a href="#writers-readers-reader-groups" class="table-of-contents__link">Writers, Readers, Reader Groups</a></li><li><a href="#stream-segments" class="table-of-contents__link">Stream Segments</a><ul><li><a href="#events-in-a-stream-segment" class="table-of-contents__link">Events in a Stream Segment</a></li><li><a href="#stream-segments-and-connection-pooling" class="table-of-contents__link">Stream Segments and Connection pooling</a></li><li><a href="#elastic-streams-auto-scaling" class="table-of-contents__link">Elastic Streams: Auto Scaling</a></li><li><a href="#events-stream-segments-and-auto-scaling" class="table-of-contents__link">Events, Stream Segments and Auto Scaling</a></li><li><a href="#stream-segments-and-reader-groups" class="table-of-contents__link">Stream Segments and Reader Groups</a></li><li><a href="#ordering-guarantees" class="table-of-contents__link">Ordering Guarantees</a></li></ul></li><li><a href="#reader-group-checkpoints" class="table-of-contents__link">Reader Group Checkpoints</a></li><li><a href="#transactions" class="table-of-contents__link">Transactions</a></li><li><a href="#state-synchronizers" class="table-of-contents__link">State Synchronizers</a></li><li><a href="#architecture" class="table-of-contents__link">Architecture</a></li><li><a href="#putting-the-concepts-together" class="table-of-contents__link">Putting the Concepts Together</a></li><li><a href="#a-note-on-tiered-storage" class="table-of-contents__link">A Note on Tiered Storage</a><ul><li><a href="#stream-retention-policies" class="table-of-contents__link">Stream Retention Policies</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/sdp/overview">SDP Docs</a></li><li class="footer__item"><a href="https://www.dell.com/support/kbdoc/en-us/000124079/dell-emc-streaming-data-platform-infohub" target="_blank" rel="noopener noreferrer" class="footer__link-item">SDP InfoHub</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/pravega" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/pravega" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/pravega" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/blog">SDP Blog</a></li><li class="footer__item"><a href="https://blog.pravega.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Pravega Blog</a></li><li class="footer__item"><a href="https://github.com/pravega/pravega" target="_blank" rel="noopener noreferrer" class="footer__link-item">Pravega GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 Dell</div></div></div></footer></div>
<script src="/docs/assets/js/styles.f634c1aa.js"></script>
<script src="/docs/assets/js/runtime~main.989135b5.js"></script>
<script src="/docs/assets/js/main.c08dfd08.js"></script>
<script src="/docs/assets/js/1.174efca1.js"></script>
<script src="/docs/assets/js/2.5b651ccc.js"></script>
<script src="/docs/assets/js/97.9490d826.js"></script>
<script src="/docs/assets/js/98.ea2e5b16.js"></script>
<script src="/docs/assets/js/935f2afb.335ada45.js"></script>
<script src="/docs/assets/js/17896441.8f7c16d3.js"></script>
<script src="/docs/assets/js/26f42c5d.dc3ff4c3.js"></script>
</body>
</html>